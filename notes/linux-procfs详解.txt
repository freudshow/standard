
目录
-----------------

0 序言
0.1 简介
0.2 责任

1 收集系统信息
1.0 proc文件系统概览
1.1 进程相关信息子目录
1.2 内核数据
1.3 IDE接口信息 /proc/ide
1.4 网络统计信息 /proc/net
1.5 SCSI接口信息 /proc/scsi
1.6 并行端口信息 /proc/parport
1.7 TTY端口信息 /proc/tty

2 调整内核参数
2.1 /proc/sys/fs - 文件系统数据
2.2 /proc/sys/fs/binfmt_misc - 二进制可执行格式杂项
2.3 /proc/sys/kernel - 通用系统参数
2.4 /proc/sys/vm - 虚拟内存系统
2.5 /proc/sys/dev - 设备相关参数
2.6 /proc/sys/sunrpc - 远程过程调用
2.7 /proc/sys/net - 网络子系统可调参数
2.8 /proc/sys/net/ipv4 - IPV4设置
2.9 Appletalk
2.10 IPX

------------------------------------------------------------------------------
绪言
------------------------------------------------------------------------------

0.1 简介
------------------------

这份文档最初是Suse Linux的一部分，在后来的时间里，它也成了Linux官方文档的一部分，并随
2.4之后版本的内核广为发布。作为对开放源代码社区的回馈，我们整理了这份不完善的文档，希望
能给需要它的人以帮助。这份文档最初是为Linux 2.2版本内核编写的，当前它也兼容于2.4版本
内核，其中一些高版本内核独有的特性在说明中都已列出。本文包含了/proc文件系统的绝大多数
方面，当然，主要针对的平台是Intel X86体系，在PPC, ARM, SPARC, APX和其他平台上可能有
少许平台特有的特性会略有不同。在网络部分本文主要针对介绍了IPv4的调整，并少许涉及IPv6、
IPX以及其他网络协议部分。

非常感谢 Alan Cox, Rik van Riel, and Alexey Kuznetsov 以及许许多多帮助编辑这份
文档的人们，也非常感谢Andi Kleen 在本文创作过程中做出的巨大贡献。
感谢每一位支持Linux和开放源码软件的人们。

如果您有任何修正、注释或添加可以联系 Bodo Bauer at bb@ricochet.net，我们非常乐意
把它加入这份文档。

本文的最新版本可以在如下地址在线阅读(HTML格式)：
http://skaro.nightcrawler.com/~bb/Docs/Proc

如果本文的提示导致您的系统有任何问题或者无法正常工作，你可以在Linux内核邮件列表上得到帮助
linux-kernel@vger.kernel.org 或联系本文原作者 comandante@zaralinux.com.

补充:
作为一份稍微有点老的文档，译者也准备添加一些新的内容，关于2.6版本内核新结构、某些商业发布
添加的内核特性(例如Redhat EL的exec-shield)以及 netfilter防火墙，在后文也会给出更多范
例和使用的调整指南。


0.2 责任
---------------
作者如是说：
我们不能保证这份文档的正确性，因此如果因为这份文档的错误导致您在系统配置过程中引发任何中断、
错误或数据损失，作者不会负任何责任，只能对您的损失表示“遗憾”。

译者如是说：
由于水平所限，我同样不能保证翻译的完整性和准确性。同时由于Linux内核是一个发展迅速的项目，将
会不断有新特性和信息加入进来，由于开源世界的大量兼容和不兼容补丁的存在，也可能有许多差异的地
方；同时相关于您的硬件环境以及加载的驱动和内核模块，可能系统表现也会略微有不同之处。
欢迎纠错与指正，信息可以反馈到 mail: freedemon &at msn &dot com


------------------------------------------------------------------------------
第一章: 收集系统信息
------------------------------------------------------------------------------

------------------------------------------------------------------------------
在这一章中，我们将...
------------------------------------------------------------------------------
* 了解Linux伪文件系统/proc的相关属性，以及系统运行期间它所能提供的信息和功能
* 考察 /proc 结构
* 研究 /proc 文件系统中的不可调(只读)内核参数/信息及其作用
------------------------------------------------------------------------------



1.0 proc文件系统总览
-----------------------------------
在类Unix系统中体现了一种良好的抽象哲学，就是几乎所有的数据实体都被抽象成一个统一的接口
--文件来看待，这样我们就可以用一些简单的基本工具完成大量复杂的操作。在Linux中存在着一类
特殊的伪文件系统，用于使用与文件接口统一的操作来完成各种功能，例如ptyfs、devfs、sysfs
和procfs。而procfs就是其中应用最广泛的一种伪文件系统。

procfs是Linux内核信息的抽象文件接口，大量内核中的信息以及可调参数都被作为常规文件映射到
一个目录树中，这样我们就可以简单直接的通过echo或cat这样的文件操作命令对系统信息进行查取
和调整了。同时procfs也提供了一个接口，使得我们自己的内核模块或用户态程序可以通过procfs
进行参数的传递。在当今的Linux系统中，大量的系统工具也通过procfs获取内核参数，例如ps、
lspci等等，没有procfs它们将可能不能正常工作。

procfs的使用如同常规的文件系统一样，例如加载一个procfs (首先确定你的内核已经支持procfs，
默认如此)：

# mount -t proc none /proc
#

也可以在/etc/fstab中加入如下一行使系统在启动时自动加载procfs(大多数系统中也是默认如此)：
none /proc proc defaults 0 0


在proc文件系统中，主要包含三大类内容，进程相关部分，系统信息部分，以及系统子系统部分。
在下面我们可以看到一个典型的procfs布局：

> ls /proc
1 2 2166 2281 cmdline interrupts meminfo stat
13 2001 2167 3 cpuinfo iomem misc swaps
1646 2042 2168 4 crypto ioports modules sys
1780 2058 2169 5 devices irq mounts sysrq-trigger
1834 2087 2170 6 dma isapnp mtrr sysvipc
1838 2096 2171 7 driver kcore net tty
1857 2107 2207 71 execdomains kmsg partitions uptime
1877 2117 2208 8 fb ksyms pci version
1889 2143 2216 9 filesystems loadavg scsi
1905 2153 2217 apm fs locks self
1960 2165 2219 bus ide mdstat slabinfo

在上面的布局中我们可以看到procfs包含的内容:
* 进程相关部分 (只读)
这部分文件都是以数字为名的子目录，这个数字就是相关进程的进程ID，在 1.1节中会详细介绍进程
相关子目录的结构和信息。
需要注意的是procfs中进程子系统部分的一个特殊点，就是/proc/self，它是指向当前执行进程的
符号连接，或者说--是指向未来你将要执行指令的心灵感应：

> cat self/cmdline 
catself/cmdline

在这个命令中，我们希望它显示当前进程的cmdline参数，它恰恰就显示了当前进程--我们所执行的
这条命令，cat self/cmdline。幸好这条指令显示出的信息会忽略空格，导致显示略微的不正常，
否则我们倒是可以很容易的使用`cat self/cmdline`这样的命令制造出永远循环执行的进程来。;>

* 内核信息部分 (只读)
这部分文件同样处于/proc的顶层目录，不过它们大部分都是常规、只读的文本文件，可以直接用cat
查看信息。作为系统内核执行体的抽象，我们也可以把它看作内核"进程"的信息部分，当然虽然并不
存在这个进程实体。这里比较特别的一个文件是 /proc/cmdline ：

>cat cmdline 
ro root=/dev/hda2

在这个文件中存放的是系统内核引导时的命令行参数。此部分内容将在 1.3节中说明。

* 内核各子系统相关部分 (部分可调)
这部分是系统内核参数调整的重头戏，在procfs中，除去上面所述的两部分内容外，还有很大一部分
信息文件被存放在了一些并非以数字命名的特殊目录中，这些目录下的信息就是内核各个重要子系统
的信息和可调参数，主要有:
bus 总线信息(只读)
drivers 驱动信息(只读)
fs 文件系统特别信息(只读)
ide IDE接口信息(只读)
irq IRQ信息(只读)
net 网络子系统信息(只读)
scsi SCSI系统信息(只读)
sysvipc IPC子系统信息(只读)
tty tty子系统信息(只读)
sys 系统内核可调参数 (可调)

作为Linux系统内核参数的抽象文件接口，Linux内核的大部分默认可调参数都被放在了 /proc/sys
目录下，这些参数都以常规文件的形式体现，并且可以用echo/cat等文件操作命令进行调整，调整的
效果是即时的，并且在系统运行的整个生命周期之间都有效(知道再次改变它们或者系统重启)。
当然Linux也提供了另外一种途径sysctl来调整这些参数，sysctl是从BSD系统继承而来的一种系统
参数动态调整方法，sysctl的使用更为简单，并且可以使用/etc/sysctl.conf保存配置以在下次启
动时自动加载这些设置。对于sysctl可调参数体积调整方法将在另一篇文章中说明。

对于内核信息和参数的说明将在 1.4 - 1.7节中解释；对于/proc/sys中的可调参数将在第二章中详
细说明。


1.1 进程相关子目录
-----------------------------------

在/proc目录中包含了一些以数字为名的子目录,这些目录就是系统当前运行进程的proc抽象。每一个
目录都以相关联的活动系统进程PID为目录名，在目录下包含了一些文件，用于显示进程相关的信息。
每个进程映射子目录的结构都如 Table 1-1.


Table 1-1: 在 /proc 目录中的进程相关入口文件
..............................................................................
文件名 内容 
cmdline 执行进程的命令行参数 
cpu 在SMP系统中近程最后的执行CPU (2.4)(smp)
cwd 到当前工作目录的符号链接
environ 环境变量 
exe 链接到进程对应的源可执行文件
fd 包含所有进程打开的文件描述符的子目录 
maps 进程内存映射，包含进程执行空间以及动态链接库信息 (2.4)
mem 进程内存空间 
root 连接到进程执行时的 / (root)目录
stat 进程状态 
statm 进程内存状态信息 
status 进程状态总览，包含进程名字、当前状态和各种信息统计 
..............................................................................

举例来说,要获取一个进程的状态,只要读取下面进程PID子目录下的status文件 /proc/PID/status:

>cat /proc/self/status 
Name: cat 
State: R (running) 
Pid: 5452 
PPid: 743 
TracerPid: 0 (2.4)
Uid: 501 501 501 501 
Gid: 100 100 100 100 
Groups: 100 14 16 
VmSize: 1112 kB 
VmLck: 0 kB 
VmRSS: 348 kB 
VmData: 24 kB 
VmStk: 12 kB 
VmExe: 8 kB 
VmLib: 1044 kB 
SigPnd: 0000000000000000 
SigBlk: 0000000000000000 
SigIgn: 0000000000000000 
SigCgt: 0000000000000000 
CapInh: 00000000fffffeff 
CapPrm: 0000000000000000 
CapEff: 0000000000000000 

如同第一节所说,/proc/self连接指向读取它自身的进程映像，在之后一节的例子中都将以
它作为我们的范例。
这条命令显示的信息与你通过 /bin/ps 命令获取到的进程信息基本相同,这恰巧是因为,ps
也是通过读取procfs来获取这些信息的。statm 文件包含了更详细的进程内存状态，statm
的详细内容按照数据项由左向右依次如 Table 1-2.

> cat /proc/self/statm
105 105 93 4 12 89 12

Table 1-2: statm文件的内容
..............................................................................
数据项 内容 
size 程序大小 
resident 常驻内存空间大小 
shared 共享内存页数 
trs 代码段占用内存页数 
drs 数据/堆栈段占用内存页数 
lrs 引用库占用内存页数 
dt 脏页数量 
..............................................................................


1.2 内核数据
---------------

相似于进程入口，在/proc目录下的其他一些文件给出了内核信息数据，这些文件包含了系统
当前运行内核相关信息。/proc目录下内核相关信息文件在Table 1-3 中列出，依赖于您的
系统配置和加载的内核模块，在您的系统中的显示可能会略有不同。

Table 1-3: Kernel info in /proc 
..............................................................................
文件 内容 
apm 高级电源管理信息 
bus bus总线相关信息 
cmdline 内核引导命令行参数 
cpuinfo cpu信息 
devices 当前可用设备 (包含所有块设备和字符设备) 
dma DMA通道使用状况 
filesystems 当前内核支持的文件系统 
driver 驱动相关信息 (2.4)
execdomains 安全相关的Execdomains信息 (2.4)
fb Frame Buffer 设备 (2.4)
fs 本地文件系统参数 (2.4)
ide IDE子系统相关信息的子目录 
interrupts 中断使用状况 
iomem 内存映射图 (2.4)
ioports I/O端口使用状况 
irq 关联到cpu的irq使用状况 (2.4)(smp?)
isapnp ISA PnP (即插即用) 信息 (2.4)
kcore Kernel core image，内核转储映像 (2.4) 
kmsg Kernel messages 
ksyms Kernel symbol table,内核符号表 
loadavg 最后1、5 、15 分钟的平均负载 
locks Kernel locks, 内核锁信息 
meminfo 内存信息 
misc 内核信息杂项 
modules 已加载内核模块列表 
mounts 已加载的文件系统 
net 网络子系统信息 
partitions 已识别的本地系统分区表 
pci PCI总线相关信息,在新版本中指向 /proc/bus/pci/ 目录 (2.4)
rtc rtc实时钟 
scsi SCSI 总线信息 
slabinfo Slab 内存分配池信息 
stat 内核状态总览 
swaps Swap 空间状态 
sys 内核系统参数 (参见第二章) 
sysvipc SysVIPC 资源状态 (msg, sem, shm) (2.4)
tty TTY驱动信息
uptime 系统 uptime 
version 内核版本 
video video 资源状态 (2.4)
..............................................................................

在proc文件系统中大多数文件都是可读的文本,可以直接使用系统中的常规文件处理命令进行操作。
当然,这也依赖于目标文件的权限属性。例如要查看系统中断信息 /proc/interrupts:

> cat /proc/interrupts 
CPU0 
0: 8728810 XT-PIC timer 
1: 895 XT-PIC keyboard 
2: 0 XT-PIC cascade 
3: 531695 XT-PIC aha152x 
4: 2014133 XT-PIC serial 
5: 44401 XT-PIC pcnet_cs 
8: 2 XT-PIC rtc 
11: 8 XT-PIC i82365 
12: 182918 XT-PIC PS/2 Mouse 
13: 1 XT-PIC fpu 
14: 1232265 XT-PIC ide0 
15: 7 XT-PIC ide1 
NMI: 0 

在2.4版内核中,当使用了SMP时这个文件末尾会多出两行SMP相关属性 LOC & ERR :

> cat /proc/interrupts 

CPU0 CPU1 
0: 1243498 1214548 IO-APIC-edge timer
1: 8949 8958 IO-APIC-edge keyboard
2: 0 0 XT-PIC cascade
5: 11286 10161 IO-APIC-edge soundblaster
8: 1 0 IO-APIC-edge rtc
9: 27422 27407 IO-APIC-edge 3c503
12: 113645 113873 IO-APIC-edge PS/2 Mouse
13: 0 0 XT-PIC fpu
14: 22491 24012 IO-APIC-edge ide0
15: 2183 2415 IO-APIC-edge ide1
17: 30564 30414 IO-APIC-level eth0
18: 177 164 IO-APIC-level bttv
NMI: 2457961 2457959 
LOC: 2457882 2457881 
ERR: 2155

NMI是每个CPU上产生的不可屏蔽中断(Non Maskable Interrupt)的计数；
LOC是每个CPU上APIC本地中断的计数。

ERR是SMP系统中IO-APIC总线失败错误的计数，如果这个数量太高，可能你的内核运行会有
问题，这时候就需要测试内核，查看硬件和APIC是否有兼容性问题。

在2.4内核中irq相关的内核信息被放在/proc/irq目录下，在这个目录下包含一个文件 
prof_cpu_mask和每个IRQ独属的一个子目录。

> ls /proc/irq/
0 10 12 14 16 18 2 4 6 8 prof_cpu_mask
1 11 13 15 17 19 3 5 7 9
> ls /proc/irq/0/
smp_affinity

2.4内核中可以使用IRQ绑定属性，是某个或全部的IRQ挂接到SMP集合中的某个CPU上，这个
特性可以通过prof_cpu_mask和smp_affinity来调整。在默认情况下这两个文件的内容都
"ffffffff"，作为一个位映射而存在，你可以使用echo命令来指定一个CPU处理IRQ事件。

> cat /proc/irq/0/smp_affinity 
ffffffff

> echo 1 > /proc/irq/prof_cpu_mask

这天命令的结果就是系统中只有第一个CPU可以捕获IRQ事件，如果您使用的是"echo 5"的话
那么第一和第四个CPU都可以捕获和处理事件(1 + 4)。

在默认情况下IRQ事件由IO-APIC分配，它将轮询每个配置中的CPU，等待其中一个处理事件
响应。

在slabinfo文件文件中我们可以看到Linux内核的内存分配池信息，2.4版本内核中使用slab
算法来为内核对象(网络缓存、目录高速缓存以及文件分配表等等)分配内存页。
在/proc目录下还有三个重要的目录: net，scsi和sys，我们会在后面的章节中陆续描述；此
外如果您的系统中没有SCSI设备(或没有SCSI驱动)的话，/proc/scsi目录是不存在的。


1.3 IDE设备 /proc/ide
----------------------------

/proc/ide目录下包含了所有内核识别出的IDE设备的信息。在/proc/ide目录下包含drivers
文件和若干个以IDE设备名或IDE控制器名为名的子目录。

> ls -alF /proc/ide/
total 3
dr-xr-xr-x 4 root root 0 10月 9 23:36 ./
dr-xr-xr-x 54 root root 0 2004-10-10 ../
-r--r--r-- 1 root root 0 10月 9 23:36 drivers
lrwxrwxrwx 1 root root 8 10月 9 23:36 hda -> ide0/hda/
lrwxrwxrwx 1 root root 8 10月 9 23:36 hdb -> ide0/hdb/
lrwxrwxrwx 1 root root 8 10月 9 23:36 hdc -> ide1/hdc/
dr-xr-xr-x 4 root root 0 10月 9 23:36 ide0/
dr-xr-xr-x 3 root root 0 10月 9 23:36 ide1/
-r--r--r-- 1 root root 0 10月 9 23:36 piix

drivers文件包含了当前加载的IDE设备驱动:

> cat /proc/ide/drivers 
ide-floppy version 0.99.newide
ide-disk version 1.17
ide-default version 0.9.newide

在/proc/ide目录下还可以看到其他一些以设备命名的目录，在这些目录下我们可以看到更
详细的信息。piix是IDE控制芯片组的名字，在你的系统中可能是其他名字。此外还包含若
干个(一般的PC上是2个)IDE控制器为名的目录，以及以IDE终端设备名命名的快捷方式，它
门将链接到控制器目录下对应的设备文件上。

在ide*目录中我们可以得到更多的信息，如 Table 1-4.

Table 1-4: IDE控制器信息 /proc/ide/ide? 
..............................................................................
文件名 内容 
channel IDE通道 (0 or 1) 
config 配置 (only for PCI/IDE bridge) 
mate Mate name 
model IDE控制器的类型/芯片组
hd? IDE总线上连接的可用设备
..............................................................................


当前连接在控制器上的每个设备也将成为一个单独的子目录，如 Table 1-5.

Table 1-5: IDE 设备信息 
..............................................................................
文件名 内容 
cache 设备缓存大小 
capacity 设备数据块数量 (按 512Byte 块) 
driver 驱动和版本 
geometry 物理和逻辑的设备参数 
identify 设备标示块 
media 媒体类型 
model 设备标识符(型号或名字) 
settings 设备配置参数 
smart_thresholds IDE disk management thresholds 
smart_values IDE disk management values 
..............................................................................

在这里比较有用的信息是settings文件，它包含了一个驱动器相关的信息总览：

# cat /proc/ide/ide0/hda/settings 
name value min max mode 
---- ----- --- --- ---- 
bios_cyl 526 0 65535 rw 
bios_head 255 0 255 rw 
bios_sect 63 0 63 rw 
breada_readahead 4 0 127 rw 
bswap 0 0 1 r 
file_readahead 72 0 2097151 rw 
io_32bit 0 0 3 rw 
keepsettings 0 0 1 rw 
max_kb_per_request 122 1 127 rw 
multcount 0 0 8 rw 
nice1 1 0 1 rw 
nowerr 0 0 1 rw 
pio_mode write-only 0 255 w 
slow 0 0 1 rw 
unmaskirq 0 0 1 rw 
using_dma 0 0 1 rw 


1.4 网络信息 /proc/net 
--------------------------------
/proc/net 子目录包含了系统中网络相关的内核统计信息和视图，常规的文件列表如 
Table 1-7 中说明； 如果你的内核支持IPV6，那么还有一些IPV6相关信息在 Table 1-6中

Table 1-6: IPv6 信息 
..............................................................................
文件名 内容 
udp6 UDP sockets (IPv6) 
tcp6 TCP sockets (IPv6) 
raw6 Raw 设备状态 (IPv6) 
igmp6 系统当前加入的IP多播地址 (IPv6) 
if_inet6 IPv6 网络接口地址列表 
ipv6_route IPv6 内核路由表 
rt6_stats IPv6 全局路由表状态 
sockstat6 Socket 状态 (IPv6) 
snmp6 Snmp 数据 (IPv6) 
..............................................................................


Table 1-7: 网络信息 /proc/net 
..............................................................................
文件名 内容 
arp 内核 ARP 表 
atm atm设备接口信息
drivers 加载的驱动模块信息
dev 网络设备以及状态 
dev_mcast 二层多播组以及监听设备信息
(包含interface index, label, number of references, number of 
bound addresses). 
dev_stat 网络设备状态 
ip_fwchains ipchains 防火墙规则链 (2.2) 
ip_fwnames ipchains 防火墙规则链名 (2.2) 
ip_masq 包含IP伪装映射表的目录 (2.2) 
ip_masquerade 主IP伪装映射表 (2.2) 
netstat 网络状态 
raw 原始设备状态 
route 内核路由表 
rpc 包含rpc信息的目录 
rt_cache 路由cache 
snmp SNMP 数据 
sockstat Socket 状态 
tcp TCP sockets 
tr_rif Token ring RIF 令牌环网路由表 
udp UDP sockets 
unix UNIX domain sockets 
wireless Wireless 接口数据 (Wavelan etc) 
igmp 主机当前加入的IP多播组地址 
psched 全局数据包调度参数 
netlink PF_NETLINK sockets 列表 
ip_mr_vifs 多播虚拟地址列表 
ip_mr_cache 多播路由cache列表 
..............................................................................

由于2.4之后的内核引入了netfilter/iptables防火墙，因此在防火墙部分的信息与2.2
略有不同：
..............................................................................
文件名 内容 
ip_tables_matches iptables支持的过滤模式
ip_tables_names iptables规则表名字
ip_tables_targets iptables规则链目标
ip_conntrack iptables状态检测跟踪表
..............................................................................

您可以使用这些信息来查看当前系统中可用的网络设备，以及这些设备上通过的流量和路由信息:

> cat /proc/net/dev 
Inter-|Receive |[... 
face |bytes packets errs drop fifo frame compressed multicast|[... 
lo: 908188 5596 0 0 0 0 0 0 [... 
ppp0:15475140 20721 410 0 0 410 0 0 [... 
eth0: 614530 7085 0 0 0 0 0 1 [... 

...] Transmit 
...] bytes packets errs drop fifo colls carrier compressed 
...] 908188 5596 0 0 0 0 0 0 
...] 1375103 17405 0 0 0 0 0 0 
...] 1703981 5535 0 0 0 3 0 0 

如果系统中使用了Ethernet Channel特性，使若干个物理接口绑定为一个逻辑设备的话，
这个逻辑设备将会拥有一个以设备名命名的子目录，其中包含一些bond模块相关的特殊信息。
例如把eth0和eth1绑定为设备 bond0 ，那么可以在 /proc/net/bond0/目录下看到bond
的特殊信息，例如主从接口、链路状态等等。


1.5 SCSI 设备信息
-------------
如果你的系统中含有任何SCSI设备，那么在 /proc/scsi 目录下可以看到系统识别到的SCSI
设备相关信息:

>cat /proc/scsi/scsi 
Attached devices: 
Host: scsi0 Channel: 00 Id: 00 Lun: 00 
Vendor: IBM Model: DGHS09U Rev: 03E0 
Type: Direct-Access ANSI SCSI revision: 03 
Host: scsi0 Channel: 00 Id: 06 Lun: 00 
Vendor: PIONEER Model: CD-ROM DR-U06S Rev: 1.04 
Type: CD-ROM ANSI SCSI revision: 02 

系统中的SCSI设备将映射到/proc/scsi目录下形成一个子树，按照对应的设备模块和设备
总线号可以查看相应设备的参数信息，例如一个Adaptec AHA-2940 SCSI 适配器:

> cat /proc/scsi/aic7xxx/0 

Adaptec AIC7xxx driver version: 5.1.19/3.2.4 
Compile Options: 
TCQ Enabled By Default : Disabled 
AIC7XXX_PROC_STATS : Disabled 
AIC7XXX_RESET_DELAY : 5 
Adapter Configuration: 
SCSI Adapter: Adaptec AHA-294X Ultra SCSI host adapter 
Ultra Wide Controller 
PCI MMAPed I/O Base: 0xeb001000 
Adapter SEEPROM Config: SEEPROM found and used. 
Adaptec SCSI BIOS: Enabled 
IRQ: 10 
SCBs: Active 0, Max Active 2, 
Allocated 15, HW 16, Page 255 
Interrupts: 160328 
BIOS Control Word: 0x18b6 
Adapter Control Word: 0x005b 
Extended Translation: Enabled 
Disconnect Enable Flags: 0xffff 
Ultra Enable Flags: 0x0001 
Tag Queue Enable Flags: 0x0000 
Ordered Queue Tag Flags: 0x0000 
Default Tag Queue Depth: 8 
Tagged Queue By Device array for aic7xxx host instance 0: 

Actual queue depth per device for aic7xxx host instance 0: 

Statistics: 
(scsi0:0:0:0) 
Device using Wide/Sync transfers at 40.0 MByte/sec, offset 8 
Transinfo settings: current(12/8/1/0), goal(12/8/1/0), user(12/15/1/0) 
Total transfers 160151 (74577 reads and 85574 writes) 
(scsi0:0:6:0) 
Device using Narrow/Sync transfers at 5.0 MByte/sec, offset 15 
Transinfo settings: current(50/15/0/0), goal(50/15/0/0), user(50/15/0/0) 
Total transfers 0 (0 reads and 0 writes) 


1.6 并口信息 /proc/parport
---------------------------------------
/proc/parport 包含系统并口信息，按照并口端口号(0,1,2,...)每个设备将映射到一个子
目录中。在这个目录下包含的信息如 Table 1-8.

Table 1-8: /proc/parport 下包含的文件信息
..............................................................................
文件名 内容 
autoprobe IEEE-1284 标准兼容的设备ID信息 
devices 端口使用的设备驱动列表 
hardware 端口使用的base address, IRQ line 和 DMA channel. 
irq 端口使用的IRQ号，你可以写入一个新值指定IRQ号 (IRQ number or none). 
..............................................................................


1.7 TTY信息 /proc/tty
-------------------------
在/proc/tty目录中包含了系统中当前在用的tty及其信息，在这个目录中也可以找到设备
信息和线路disciplines，如 Table 1-9.

Table 1-9: /proc/tty 中的文件
..............................................................................
文件名 内容 
drivers 设备及引用计数 
ldiscs registered line disciplines 
driver/serial tty线路状态 
..............................................................................

要查看系统中的当前在用ttys，可以简单的查看 /proc/tty/drivers:

> cat /proc/tty/drivers 
pty_slave /dev/pts 136 0-255 pty:slave 
pty_master /dev/ptm 128 0-255 pty:master 
pty_slave /dev/ttyp 3 0-255 pty:slave 
pty_master /dev/pty 2 0-255 pty:master 
serial /dev/cua 5 64-67 serial:callout 
serial /dev/ttyS 4 64-67 serial 
/dev/tty0 /dev/tty0 4 0 system:vtmaster 
/dev/ptmx /dev/ptmx 5 2 system 
/dev/console /dev/console 5 1 system:console 
/dev/tty /dev/tty 5 0 system:/dev/tty 
unknown /dev/tty 4 1-63 console 


------------------------------------------------------------------------------
摘要
------------------------------------------------------------------------------
本章介绍了 /proc 文件系统提供的系统运行时信息. 在 /proc 文件系统中，您不仅可以
简单直接的访问进程相关信息，也可以通过它查看各个方面的系统内核状态。

在 /proc 文件系统中，大部分信息都以常规或文本文件的形式反映出来，您可以任意使用
简单的文件处理命令来查看它(只要权限允许)；如果某些文件不能被查看或者产生乱码，那
么它可能是一些特殊类型的文件，需要其它手段来处理，例如 /proc/kcore 可以通过gdb
等内核调试工具来查看，而其他一些数据则可以被ps、top等工具所理解。


在这一章中，我们对procfs的结构进行了一下纵览，对它的作用也该有一些了解了。在procfs中除了得到大量系统内核信息之外，它最重要的一个作用莫过于对进程的监控和分析了。有了procfs，你也可以写出自己的ps/top来，甚至不用任何编程工具......

比如，很多Linux新手都常常遇到的一个问题，就是夹在了一个文件系统之后不能卸载，系统报告这样的错误:


代码:
# umount /db1                                            
umount: /db1: device is busy

经验老到的管理员们都知道，这个问题是由于某些进程的工作目录还在这个目录下，导致系统卷忙而无法卸载，只要杀掉那个进程，文件系统就可以正常卸载了。但究竟是哪个进程还在那里呢？找起来恐怕也要费半天神。虽然有pfile和lsof之类的工具可用，但总 也有应急的时候吧，这棵小脚本就可以为你解忧。


代码:
#!/bin/bash
#pcwd.sh,查找系统中工作在目标路径下的进程，使用方法: pcwd.sh 路径名

test  || { echo "Usage: pcwd.sh path(absolute path)" && exit };

PS=`ls /proc/*[0-9]*|grep :` ;
PSList=`echo $PS |tr -d '/proc'|tr -d ':'`;
for PID in $PSList
  do
  test -e /proc/$PID && (ls -alF /proc/$PID/cwd|grep  >/dev/null ) && echo "Process $PID (`cat /proc/$PID/status |grep Name |tr -d 'Name:\t'`) is work in  ";
done


就是这样短短的几行代码，甚至不用任何的临时文件，我们就获取了执行命令前的当前系统进程表映像，然后遍历每个进程的proc目录，找到占用我们目录的"坏进程"。

在我的系统上的输出: 
代码:
[elly@frost.llnl]/tmp# ./pcwd.sh 
Usage: pcwd.sh path(absolute path)

[elly@frost.llnl]/tmp# ./pcwd.sh /usr
Process 1283 (vi) is work in /usr ;
Process 3113 (bsh) is work in /usr ;

在上面的例子中,我们只用了最简单的四五个文件和文本处理命令,就完成了这个小程序,你甚至可以把所有的语句写在一行上,通过命令行或alias定义就完成这个功能。

把它稍稍修改一下就是另外一个功能,查找正在使用某个文件的进程:


代码:
#!/bin/bash

test  || { echo "Usage: pfile.sh filename(absolute path)" && exit };

PS=`ls /proc/*[0-9]*|grep :` ;
PSList=`echo $PS |tr -d '/proc'|tr -d ':'`;
for PID in $PSList
  do
  test -e /proc/$PID && (ls -alF /proc/$PID/fd|grep  >/dev/null ) && echo "Process $PID (`cat /proc/$PID/status |grep Name |tr -d 'Name:\t'`) is openning ;";
done


在我系统上的输出: 

代码:
[elly@frost.llnl]/tmp# ./pfile.sh 
Usage: pfile.sh filename(absolute path)

[elly@frost.llnl]/tmp# ./pfile.sh access_log
Process 109 (httpd) is openning access_log;
Process 110 (httpd) is openning access_log;
Process 112 (httpd) is openning access_log;
Process 113 (httpd) is openning access_log;
Process 116 (httpd) is openning access_log;
Process 99 (httpd) is openning access_log;


目标文件名可以使用相对或绝对路径，甚至可以只输入半个文件名...当然路径越精确查找的结果也越准确。在这个例子中，很容易就可以扩展它的功能,让它实现类似lsof的功能，可以列举系统中所有正在被使用的文件。
好啦，我们做一个有用点的程序。

ps，每台机器上都有吧。不幸的是，在某些极端环境下，系统中的PS是不可靠的，比如，坏了...或被人替换了。

很多恶意的黑客入侵系统之后会在系统上安装一类叫rootkit的后门包，用来替换系统中ps、netstat等重要程序以隐藏自己的痕迹，这个时候一般比较稳妥的办法是自己上传一份可靠的系统工具包，或者静态编译的工具包。当然，也可以用这个土办法，直 接从procfs里读取信息。(如果是比较高明的黑客，使用LKM等内核后门那这个就没有用了哦)

范例:懒人的ps，就叫它lps吧。 

代码:
#!/bin/bash


PS=`ls /proc/*[0-9]*|grep :` ;
PSList=`echo $PS |tr -d '/proc' |tr -d ':' |sort `;

echo -e "PID\tPPID\tUID\tGID\tSTAT\t\tMEM\tTTY\tCMD"
for PID in $PSList
  do
  test -e /proc/$PID && sPID=`cat /proc/$PID/status |grep ^Pid: |awk '{print }'`   && sPPID=`cat /proc/$PID/status |grep ^PPid: |awk '{print }'`   && sTTY=`ls -alF /proc/$PID/fd |grep /dev/ |awk '{print }' |grep ty |head -n 1`   && sUID=`cat /proc/$PID/status |grep ^Uid: |awk '{print }'`   && sGID=`cat /proc/$PID/status |grep ^Gid: |awk '{print }'`   && sSTAT=`cat /proc/$PID/status |grep ^State: |awk '{print  }'`   && sMEM=`cat /proc/$PID/status |grep ^VmSize: |awk '{print  }'`   && if [ -e /proc/$PID/exe ]
  then 
     sCMD=`ls -alF /proc/$PID/exe |awk '{print }' |tr -d '$*' `
  else
     sCMD=`cat /proc/$PID/status |grep ^Name: |awk '{print }'`
     sCMD="[ $sCMD ]"
  fi

  echo -e "$sPID\t$sPPID\t$sUID\t$sGID\t$sSTAT\t$sMEM\t$sTTY\t$sCMD"
done



简要介绍,这个lps或列举系统中自身进程(lps)之外的所有进程，然后读取和显示他们的八项属性，依次是:
进程ID(PID) 父进程ID(PPID) 属主UID(UID) 属主GID(GID) 当前状态 占用内存 运行终端 完全执行路径。

在显示格式参考了Linux标准ps输出的一部分，例如某些系统线程没有可执行文件的，就会显示他们的内核名字，例如[ ksoftirqd_CPU0 ] 。
懒人的PS中没有任何参数，你也可以扩展它的功能，使之能支持按照进程树状显示等等。

在我系统上的输出: 

代码:
[elly@frost.llnl]/tmp# ./lps.sh 
PID     PPID    UID     GID     STAT            MEM     TTY     CMD
1       0       0       0       S(sleeping)     1116kB          /sbin/init
101     1       0       0       S(sleeping)     2168kB          /usr/local/sbin/sshd
109     99      99      99      S(sleeping)     6100kB          /usr/local/apache/bin/httpd
110     99      99      99      S(sleeping)     6100kB          /usr/local/apache/bin/httpd
112     99      99      99      S(sleeping)     6100kB          /usr/local/apache/bin/httpd
113     99      99      99      S(sleeping)     6100kB          /usr/local/apache/bin/httpd
116     99      99      99      S(sleeping)     6100kB          /usr/local/apache/bin/httpd
118     1       0       0       S(sleeping)     1656kB          /bin/bash
119     1       0       0       S(sleeping)     1648kB          /bin/bash
120     1       0       0       S(sleeping)     1648kB          /bin/bash
128     1       0       0       S(sleeping)     2224kB  /dev/tty1       /bin/login
1283    3113    0       0       S(sleeping)     1512kB  /dev/ttyp0      /bin/vi
129     1       0       0       S(sleeping)     1136kB  /dev/tty2       /sbin/getty
130     1       0       0       S(sleeping)     1136kB  /dev/tty3       /sbin/getty
131     1       0       0       S(sleeping)     1136kB  /dev/tty4       /sbin/getty
135     1       0       0       S(sleeping)     1136kB  /dev/tty5       /sbin/getty
136     1       0       0       S(sleeping)     1136kB  /dev/tty6       /sbin/getty
137     1       0       0       S(sleeping)     1140kB  /dev/ttyS0      /sbin/getty
15329   3112    0       0       S(sleeping)     1792kB  /dev/ttyp1      /bin/bash
2       1       0       0       S(sleeping)                     [ keventd ]
256     128     0       0       S(sleeping)     1712kB  /dev/tty1       /bin/bash
3       1       0       0       S(sleeping)                     [ ksoftirqd_CPU0 ]
3112    101     0       0       S(sleeping)     2452kB  /dev/ptyp1      /usr/local/sbin/sshd
3113    3112    0       0       S(sleeping)     1728kB  /dev/ttyp0      /bin/bash
3872    120     0       0       S(sleeping)     1084kB          /bin/sleep
4       1       0       0       S(sleeping)                     [ kswapd ]
4       1       0       0       S(sleeping)                     [ kswapd ]
4       1       0       0       S(sleeping)                     [ kswapd ]
4089    15329   0       0       S(sleeping)     1664kB  /dev/ttyp1      /bin/bash
4089    15329   0       0       S(sleeping)     1664kB  /dev/ttyp1      /bin/bash
5       1       0       0       S(sleeping)                     [ bdflush ]
6       1       0       0       S(sleeping)                     [ kupdated ]
99      1       0       0       S(sleeping)     6016kB          /usr/local/apache/bin/httpd
最后一个！

信息，我要更多一点。

Solaris上有/usr/proc/bin工具集，里面的ptree和pmap很是好用，甚至比本来的ps还好:P
可惜Linux上是没有的，现在你可以自己写一个，用来综合显示更多的进程状态。

代码:
#!/bin/bash
#PROC=`mount |grep 'type proc'|awk '{print }'`

test  || { echo "Usage: pstat.sh PID" && exit };
PID=;

echo "Process  Status...";
echo "......................";
echo 
cat /proc/$PID/status|grep ^Name: 
cat /proc/$PID/status|grep ^Pid: 
cat /proc/$PID/status|grep ^PPid: 
cat /proc/$PID/status|grep ^Uid:
cat /proc/$PID/status|grep ^Gid:
cat /proc/$PID/status|grep ^State:
cat /proc/$PID/status|grep ^VmSize:
echo
CMD=`ls -alF /proc/$PID/exe |awk '{print }' |tr -d '$*'`;echo "Command path: $CMD";
ARG=`cat /proc/$PID/cmdline`;echo "Command line: $ARG";
CWD=`ls -alF /proc/$PID/cwd |awk '{print }'`;echo "CWD: $CWD";
echo
ENVI=`cat /proc/$PID/environ`;echo "ENVIRON: $ENVI";
echo
echo
echo "Process shared object:";
echo "......................";
cat /proc/$PID/maps |grep $CMD |grep xp;
cat /proc/$PID/maps |grep .so |grep xp;
echo
echo
echo "Process used file:";
echo "......................";
ls -alF /proc/$PID/fd |grep '\->' |awk '{print }' |sort |uniq -c |sort -rn ;
echo



这个程序叫pstat.sh，可以显示进程的综合信息。输出分为四段，分别是进程状态(包含父子进程关系、进程信任状以及内存占用)，执行环境(包含进程执行程序，命令行参数和环境变量)，进程执行对象(包含进程执行体和引用的共享库)，最后是进程打开的 所有文件。

代码:
[elly@frost.llnl]/tmp# ./pstat.sh
Usage: pstat.sh PID

[elly@frost.llnl]/tmp# ./pstat.sh 7238
Process 7238 Status...
......................

Name:   vi
Pid:    7238
PPid:   3113
Uid:    0       0       0       0
Gid:    0       0       0       0
State:  S (sleeping)
VmSize:     1648 kB

Command path: /bin/vi
Command line: vi
CWD: /usr/

ENVIRON: USERNAME=root


Process shared object:
......................
08048000-08098000 r-xp 00000000 03:01 3891       /bin/vi
40000000-40013000 r-xp 00000000 03:01 3942       /lib/ld-2.1.3.so
40016000-40019000 r-xp 00000000 03:01 4002       /lib/libtermcap.so.2.0.8
4001a000-40107000 r-xp 00000000 03:01 3949       /lib/libc-2.1.3.so
4010f000-40117000 r-xp 00000000 03:01 3981       /lib/libnss_files-2.1.3.so


Process used file:
......................
/dev/ttyp0
/etc/motd

进程游戏就玩到这里。

如果你有足够的细心和耐心，你可以按照上面的程序框架完成任何其他编程语言能够完成的工作。考虑到通用性，我没有使用任何临时文件，因此在实现上会有更多的困难和限制。不过程序框架已经在这里了，扩展它需要更多的知识执行流程和错误处理。中国移动说，你能 。

下一章会继续回到procfs的主题上，讲述通过procfs进行系统参数的调整和配置




T H E  /proc   F I L E S Y S T E M
------------------------------------------------------------------------------
/proc/sys         Terrehon Bowden <terrehon@pacbell.net>        October 7 1999
                  Bodo Bauer <bb@ricochet.net>
 
2.4.x update   Jorge Nerin <comandante@zaralinux.com>      November 14 2000
------------------------------------------------------------------------------
Version 1.3                                              Kernel version 2.2.12
           Kernel version 2.4.0-test11-pre4
------------------------------------------------------------------------------
 
Table of Contents
-----------------
 
  0     Preface
  0.1 Introduction/Credits
  0.2 Legal Stuff
 
  1 Collecting System Information
  1.1 Process-Specific Subdirectories
  1.2 Kernel data
  1.3 IDE devices in /proc/ide
  1.4 Networking info in /proc/net
  1.5 SCSI info
  1.6 Parallel port info in /proc/parport
  1.7 TTY info in /proc/tty
  1.8 Miscellaneous kernel statistics in /proc/stat
 
  2 Modifying System Parameters
  2.1 /proc/sys/fs - File system data
  2.2 /proc/sys/fs/binfmt_misc - Miscellaneous binary formats
  2.3 /proc/sys/kernel - general kernel parameters
  2.4 /proc/sys/vm - The virtual memory subsystem
  2.5 /proc/sys/dev - Device specific parameters
  2.6 /proc/sys/sunrpc - Remote procedure calls
  2.7 /proc/sys/net - Networking stuff
  2.8 /proc/sys/net/ipv4 - IPV4 settings
  2.9 Appletalk
  2.10 IPX
  2.11 /proc/sys/fs/mqueue - POSIX message queues filesystem
  2.12 /proc/<pid>/oom_adj - Adjust the oom-killer score
  2.13 /proc/<pid>/oom_score - Display current oom-killer score
  2.14 /proc/<pid>/io - Display the IO accounting fields
  2.15 /proc/<pid>/coredump_filter - Core dump filtering settings
 
------------------------------------------------------------------------------
Preface
------------------------------------------------------------------------------
 
0.1 Introduction/Credits
------------------------
 
This documentation is  part of a soon (or  so we hope) to be  released book on
the SuSE  Linux distribution. As  there is  no complete documentation  for the
/proc file system and we've used  many freely available sources to write these
chapters, it  seems only fair  to give the work  back to the  Linux community.
This work is  based on the 2.2.*  kernel version and the  upcoming 2.4.*. I'm
afraid it's still far from complete, but we  hope it will be useful. As far as
we know, it is the first 'all-in-one' document about the /proc file system. It
is focused  on the Intel  x86 hardware,  so if you  are looking for  PPC, ARM,
SPARC, AXP, etc., features, you probably  won't find what you are looking for.
It also only covers IPv4 networking, not IPv6 nor other protocols - sorry. But
additions and patches  are welcome and will  be added to this  document if you
mail them to Bodo.
 
We'd like  to  thank Alan Cox, Rik van Riel, and Alexey Kuznetsov and a lot of
other people for help compiling this documentation. We'd also like to extend a
special thank  you to Andi Kleen for documentation, which we relied on heavily
to create  this  document,  as well as the additional information he provided.
Thanks to  everybody  else  who contributed source or docs to the Linux kernel
and helped create a great piece of software... :)
 
If you  have  any comments, corrections or additions, please don't hesitate to
contact Bodo  Bauer  at  bb@ricochet.net.  We'll  be happy to add them to this
document.
 
The   latest   version    of   this   document   is    available   online   at
http://skaro.nightcrawler.com/~bb/Docs/Proc as HTML version.
 
If  the above  direction does  not works  for you,  ypu could  try the  kernel
mailing  list  at  linux-kernel@vger.kernel.org  and/or try  to  reach  me  at
comandante@zaralinux.com.
 
0.2 Legal Stuff
---------------
 
We don't  guarantee  the  correctness  of this document, and if you come to us
complaining about  how  you  screwed  up  your  system  because  of  incorrect
documentation, we won't feel responsible...
 
------------------------------------------------------------------------------
CHAPTER 1: COLLECTING SYSTEM INFORMATION
------------------------------------------------------------------------------
 
------------------------------------------------------------------------------
In This Chapter
------------------------------------------------------------------------------
* Investigating  the  properties  of  the  pseudo  file  system  /proc and its
  ability to provide information on the running Linux system
* Examining /proc's structure
* Uncovering  various  information  about the kernel and the processes running
  on the system
------------------------------------------------------------------------------
 

The proc  file  system acts as an interface to internal data structures in the
kernel. It  can  be  used to obtain information about the system and to change
certain kernel parameters at runtime (sysctl).
 
First, we'll  take  a  look  at the read-only parts of /proc. In Chapter 2, we
show you how you can use /proc/sys to change settings.
 
1.1 Process-Specific Subdirectories
-----------------------------------
 
The directory  /proc  contains  (among other things) one subdirectory for each
process running on the system, which is named after the process ID (PID).
 
The link  self  points  to  the  process reading the file system. Each process
subdirectory has the entries listed in Table 1-1.
 

Table 1-1: Process specific entries in /proc 
..............................................................................
 File  Content
 clear_refs Clears page referenced bits shown in smaps output
 cmdline Command line arguments
 cpu  Current and last cpu in which it was executed (2.4)(smp)
 cwd  Link to the current working directory
 environ Values of environment variables
 exe  Link to the executable of this process
 fd  Directory, which contains all file descriptors
 maps  Memory maps to executables and library files (2.4)
 mem  Memory held by this process
 root  Link to the root directory of this process
 stat  Process status
 statm  Process memory status information
 status  Process status in human readable form
 wchan  If CONFIG_KALLSYMS is set, a pre-decoded wchan
 smaps  Extension based on maps, the rss size for each mapped file
..............................................................................
 
For example, to get the status information of a process, all you have to do is
read the file /proc/PID/status:
 
  >cat /proc/self/status 
  Name:   cat 
  State:  R (running) 
  Pid:    5452 
  PPid:   743 
  TracerPid:      0      (2.4)
  Uid:    501     501     501     501 
  Gid:    100     100     100     100 
  Groups: 100 14 16 
  VmSize:     1112 kB 
  VmLck:         0 kB 
  VmRSS:       348 kB 
  VmData:       24 kB 
  VmStk:        12 kB 
  VmExe:         8 kB 
  VmLib:      1044 kB 
  SigPnd: 0000000000000000 
  SigBlk: 0000000000000000 
  SigIgn: 0000000000000000 
  SigCgt: 0000000000000000 
  CapInh: 00000000fffffeff 
  CapPrm: 0000000000000000 
  CapEff: 0000000000000000 
 

This shows you nearly the same information you would get if you viewed it with
the ps  command.  In  fact,  ps  uses  the  proc  file  system  to  obtain its
information. The  statm  file  contains  more  detailed  information about the
process memory usage. Its seven fields are explained in Table 1-2.  The stat
file contains details information about the process itself.  Its fields are
explained in Table 1-3.
 

Table 1-2: Contents of the statm files (as of 2.6.8-rc3)
..............................................................................
 Field    Content
 size     total program size (pages)  (same as VmSize in status)
 resident size of memory portions (pages) (same as VmRSS in status)
 shared   number of pages that are shared (i.e. backed by a file)
 trs      number of pages that are 'code' (not including libs; broken,
       includes data segment)
 lrs      number of pages of library  (always 0 on 2.6)
 drs      number of pages of data/stack  (including libs; broken,
       includes library text)
 dt       number of dirty pages   (always 0 on 2.6)
..............................................................................
 

Table 1-3: Contents of the stat files (as of 2.6.22-rc3)
..............................................................................
 Field          Content
  pid           process id
  tcomm         filename of the executable
  state         state (R is running, S is sleeping, D is sleeping in an
                uninterruptible wait, Z is zombie, T is traced or stopped)
  ppid          process id of the parent process
  pgrp          pgrp of the process
  sid           session id
  tty_nr        tty the process uses
  tty_pgrp      pgrp of the tty
  flags         task flags
  min_flt       number of minor faults
  cmin_flt      number of minor faults with child's
  maj_flt       number of major faults
  cmaj_flt      number of major faults with child's
  utime         user mode jiffies
  stime         kernel mode jiffies
  cutime        user mode jiffies with child's
  cstime        kernel mode jiffies with child's
  priority      priority level
  nice          nice level
  num_threads   number of threads
  start_time    time the process started after system boot
  vsize         virtual memory size
  rss           resident set memory size
  rsslim        current limit in bytes on the rss
  start_code    address above which program text can run
  end_code      address below which program text can run
  start_stack   address of the start of the stack
  esp           current value of ESP
  eip           current value of EIP
  pending       bitmap of pending signals (obsolete)
  blocked       bitmap of blocked signals (obsolete)
  sigign        bitmap of ignored signals (obsolete)
  sigcatch      bitmap of catched signals (obsolete)
  wchan         address where process went to sleep
  0             (place holder)
  0             (place holder)
  exit_signal   signal to send to parent thread on exit
  task_cpu      which CPU the task is scheduled on
  rt_priority   realtime priority
  policy        scheduling policy (man sched_setscheduler)
  blkio_ticks   time spent waiting for block IO
..............................................................................
 

1.2 Kernel data
---------------
 
Similar to  the  process entries, the kernel data files give information about
the running kernel. The files used to obtain this information are contained in
/proc and  are  listed  in Table 1-4. Not all of these will be present in your
system. It  depends  on the kernel configuration and the loaded modules, which
files are there, and which are missing.
 
Table 1-4: Kernel info in /proc
..............................................................................
 File        Content                                           
 apm         Advanced power management info                    
 buddyinfo   Kernel memory allocator information (see text) (2.5)
 bus         Directory containing bus specific information     
 cmdline     Kernel command line                               
 cpuinfo     Info about the CPU                                
 devices     Available devices (block and character)           
 dma         Used DMS channels                                 
 filesystems Supported filesystems                             
 driver      Various drivers grouped here, currently rtc (2.4)
 execdomains Execdomains, related to security   (2.4)
 fb      Frame Buffer devices    (2.4)
 fs      File system parameters, currently nfs/exports (2.4)
 ide         Directory containing info about the IDE subsystem 
 interrupts  Interrupt usage                                   
 iomem      Memory map      (2.4)
 ioports     I/O port usage                                    
 irq      Masks for irq to cpu affinity   (2.4)(smp?)
 isapnp      ISA PnP (Plug&Play) Info    (2.4)
 kcore       Kernel core image (can be ELF or A.OUT(deprecated in 2.4))   
 kmsg        Kernel messages                                   
 ksyms       Kernel symbol table                               
 loadavg     Load average of last 1, 5 & 15 minutes                
 locks       Kernel locks                                      
 meminfo     Memory info                                       
 misc        Miscellaneous                                     
 modules     List of loaded modules                            
 mounts      Mounted filesystems                               
 net         Networking info (see text)                        
 partitions  Table of partitions known to the system           
 pci      Deprecated info of PCI bus (new way -> /proc/bus/pci/,
             decoupled by lspci     (2.4)
 rtc         Real time clock                                   
 scsi        SCSI info (see text)                              
 slabinfo    Slab pool info                                    
 stat        Overall statistics                                
 swaps       Swap space utilization                            
 sys         See chapter 2                                     
 sysvipc     Info of SysVIPC Resources (msg, sem, shm)  (2.4)
 tty      Info of tty drivers
 uptime      System uptime                                     
 version     Kernel version                                    
 video      bttv info of video resources   (2.4)
..............................................................................
 
You can,  for  example,  check  which interrupts are currently in use and what
they are used for by looking in the file /proc/interrupts:
 
  > cat /proc/interrupts 
             CPU0        
    0:    8728810          XT-PIC  timer 
    1:        895          XT-PIC  keyboard 
    2:          0          XT-PIC  cascade 
    3:     531695          XT-PIC  aha152x 
    4:    2014133          XT-PIC  serial 
    5:      44401          XT-PIC  pcnet_cs 
    8:          2          XT-PIC  rtc 
   11:          8          XT-PIC  i82365 
   12:     182918          XT-PIC  PS/2 Mouse 
   13:          1          XT-PIC  fpu 
   14:    1232265          XT-PIC  ide0 
   15:          7          XT-PIC  ide1 
  NMI:          0 
 
In 2.4.* a couple of lines where added to this file LOC & ERR (this time is the
output of a SMP machine):
 
  > cat /proc/interrupts 
 
             CPU0       CPU1       
    0:    1243498    1214548    IO-APIC-edge  timer
    1:       8949       8958    IO-APIC-edge  keyboard
    2:          0          0          XT-PIC  cascade
    5:      11286      10161    IO-APIC-edge  soundblaster
    8:          1          0    IO-APIC-edge  rtc
    9:      27422      27407    IO-APIC-edge  3c503
   12:     113645     113873    IO-APIC-edge  PS/2 Mouse
   13:          0          0          XT-PIC  fpu
   14:      22491      24012    IO-APIC-edge  ide0
   15:       2183       2415    IO-APIC-edge  ide1
   17:      30564      30414   IO-APIC-level  eth0
   18:        177        164   IO-APIC-level  bttv
  NMI:    2457961    2457959 
  LOC:    2457882    2457881 
  ERR:       2155
 
NMI is incremented in this case because every timer interrupt generates a NMI
(Non Maskable Interrupt) which is used by the NMI Watchdog to detect lockups.
 
LOC is the local interrupt counter of the internal APIC of every CPU.
 
ERR is incremented in the case of errors in the IO-APIC bus (the bus that
connects the CPUs in a SMP system. This means that an error has been detected,
the IO-APIC automatically retry the transmission, so it should not be a big
problem, but you should read the SMP-FAQ.
 
In 2.6.2* /proc/interrupts was expanded again.  This time the goal was for
/proc/interrupts to display every IRQ vector in use by the system, not
just those considered 'most important'.  The new vectors are:
 
  THR -- interrupt raised when a machine check threshold counter
  (typically counting ECC corrected errors of memory or cache) exceeds
  a configurable threshold.  Only available on some systems.
 
  TRM -- a thermal event interrupt occurs when a temperature threshold
  has been exceeded for the CPU.  This interrupt may also be generated
  when the temperature drops back to normal.
 
  SPU -- a spurious interrupt is some interrupt that was raised then lowered
  by some IO device before it could be fully processed by the APIC.  Hence
  the APIC sees the interrupt but does not know what device it came from.
  For this case the APIC will generate the interrupt with a IRQ vector
  of 0xff. This might also be generated by chipset bugs.
 
  RES, CAL, TLB -- rescheduling, call and TLB flush interrupts are
  sent from one CPU to another per the needs of the OS.  Typically,
  their statistics are used by kernel developers and interested users to
  determine the occurance of interrupt of the given type.
 
The above IRQ vectors are displayed only when relevent.  For example,
the threshold vector does not exist on x86_64 platforms.  Others are
suppressed when the system is a uniprocessor.  As of this writing, only
i386 and x86_64 platforms support the new IRQ vector displays.
 
Of some interest is the introduction of the /proc/irq directory to 2.4.
It could be used to set IRQ to CPU affinity, this means that you can "hook" an
IRQ to only one CPU, or to exclude a CPU of handling IRQs. The contents of the
irq subdir is one subdir for each IRQ, and one file; prof_cpu_mask
 
For example 
  > ls /proc/irq/
  0  10  12  14  16  18  2  4  6  8  prof_cpu_mask
  1  11  13  15  17  19  3  5  7  9
  > ls /proc/irq/0/
  smp_affinity
 
The contents of the prof_cpu_mask file and each smp_affinity file for each IRQ
is the same by default:
 
  > cat /proc/irq/0/smp_affinity 
  ffffffff
 
It's a bitmask, in which you can specify which CPUs can handle the IRQ, you can
set it by doing:
 
  > echo 1 > /proc/irq/prof_cpu_mask
 
This means that only the first CPU will handle the IRQ, but you can also echo 5
which means that only the first and fourth CPU can handle the IRQ.
 
The way IRQs are routed is handled by the IO-APIC, and it's Round Robin
between all the CPUs which are allowed to handle it. As usual the kernel has
more info than you and does a better job than you, so the defaults are the
best choice for almost everyone.
 
There are  three  more  important subdirectories in /proc: net, scsi, and sys.
The general  rule  is  that  the  contents,  or  even  the  existence of these
directories, depend  on your kernel configuration. If SCSI is not enabled, the
directory scsi  may  not  exist. The same is true with the net, which is there
only when networking support is present in the running kernel.
 
The slabinfo  file  gives  information  about  memory usage at the slab level.
Linux uses  slab  pools for memory management above page level in version 2.2.
Commonly used  objects  have  their  own  slab  pool (such as network buffers,
directory cache, and so on).
 
..............................................................................
 
> cat /proc/buddyinfo
 
Node 0, zone      DMA      0      4      5      4      4      3 ...
Node 0, zone   Normal      1      0      0      1    101      8 ...
Node 0, zone  HighMem      2      0      0      1      1      0 ...
 
Memory fragmentation is a problem under some workloads, and buddyinfo is a 
useful tool for helping diagnose these problems.  Buddyinfo will give you a 
clue as to how big an area you can safely allocate, or why a previous
allocation failed.
 
Each column represents the number of pages of a certain order which are 
available.  In this case, there are 0 chunks of 2^0*PAGE_SIZE available in 
ZONE_DMA, 4 chunks of 2^1*PAGE_SIZE in ZONE_DMA, 101 chunks of 2^4*PAGE_SIZE 
available in ZONE_NORMAL, etc... 
 
..............................................................................
 
meminfo:
 
Provides information about distribution and utilization of memory.  This
varies by architecture and compile options.  The following is from a
16GB PIII, which has highmem enabled.  You may not have all of these fields.
 
> cat /proc/meminfo
 

MemTotal:     16344972 kB
MemFree:      13634064 kB
Buffers:          3656 kB
Cached:        1195708 kB
SwapCached:          0 kB
Active:         891636 kB
Inactive:      1077224 kB
HighTotal:    15597528 kB
HighFree:     13629632 kB
LowTotal:       747444 kB
LowFree:          4432 kB
SwapTotal:           0 kB
SwapFree:            0 kB
Dirty:             968 kB
Writeback:           0 kB
Mapped:         280372 kB
Slab:           684068 kB
CommitLimit:   7669796 kB
Committed_AS:   100056 kB
PageTables:      24448 kB
VmallocTotal:   112216 kB
VmallocUsed:       428 kB
VmallocChunk:   111088 kB
 
    MemTotal: Total usable ram (i.e. physical ram minus a few reserved
              bits and the kernel binary code)
     MemFree: The sum of LowFree+HighFree
     Buffers: Relatively temporary storage for raw disk blocks
              shouldn't get tremendously large (20MB or so)
      Cached: in-memory cache for files read from the disk (the
              pagecache).  Doesn't include SwapCached
  SwapCached: Memory that once was swapped out, is swapped back in but
              still also is in the swapfile (if memory is needed it
              doesn't need to be swapped out AGAIN because it is already
              in the swapfile. This saves I/O)
      Active: Memory that has been used more recently and usually not
              reclaimed unless absolutely necessary.
    Inactive: Memory which has been less recently used.  It is more
              eligible to be reclaimed for other purposes
   HighTotal:
    HighFree: Highmem is all memory above ~860MB of physical memory
              Highmem areas are for use by userspace programs, or
              for the pagecache.  The kernel must use tricks to access
              this memory, making it slower to access than lowmem.
    LowTotal:
     LowFree: Lowmem is memory which can be used for everything that
              highmem can be used for, but it is also available for the
              kernel's use for its own data structures.  Among many
              other things, it is where everything from the Slab is
              allocated.  Bad things happen when you're out of lowmem.
   SwapTotal: total amount of swap space available
    SwapFree: Memory which has been evicted from RAM, and is temporarily
              on the disk
       Dirty: Memory which is waiting to get written back to the disk
   Writeback: Memory which is actively being written back to the disk
      Mapped: files which have been mmaped, such as libraries
        Slab: in-kernel data structures cache
 CommitLimit: Based on the overcommit ratio ('vm.overcommit_ratio'),
              this is the total amount of  memory currently available to
              be allocated on the system. This limit is only adhered to
              if strict overcommit accounting is enabled (mode 2 in
              'vm.overcommit_memory').
              The CommitLimit is calculated with the following formula:
              CommitLimit = ('vm.overcommit_ratio' * Physical RAM) + Swap
              For example, on a system with 1G of physical RAM and 7G
              of swap with a `vm.overcommit_ratio` of 30 it would
              yield a CommitLimit of 7.3G.
              For more details, see the memory overcommit documentation
              in vm/overcommit-accounting.
Committed_AS: The amount of memory presently allocated on the system.
              The committed memory is a sum of all of the memory which
              has been allocated by processes, even if it has not been
              "used" by them as of yet. A process which malloc()'s 1G
              of memory, but only touches 300M of it will only show up
              as using 300M of memory even if it has the address space
              allocated for the entire 1G. This 1G is memory which has
              been "committed" to by the VM and can be used at any time
              by the allocating application. With strict overcommit
              enabled on the system (mode 2 in 'vm.overcommit_memory'),
              allocations which would exceed the CommitLimit (detailed
              above) will not be permitted. This is useful if one needs
              to guarantee that processes will not fail due to lack of
              memory once that memory has been successfully allocated.
  PageTables: amount of memory dedicated to the lowest level of page
              tables.
VmallocTotal: total size of vmalloc memory area
 VmallocUsed: amount of vmalloc area which is used
VmallocChunk: largest contigious block of vmalloc area which is free
 

1.3 IDE devices in /proc/ide
----------------------------
 
The subdirectory /proc/ide contains information about all IDE devices of which
the kernel  is  aware.  There is one subdirectory for each IDE controller, the
file drivers  and a link for each IDE device, pointing to the device directory
in the controller specific subtree.
 
The file  drivers  contains general information about the drivers used for the
IDE devices:
 
  > cat /proc/ide/drivers
  ide-cdrom version 4.53
  ide-disk version 1.08
 
More detailed  information  can  be  found  in  the  controller  specific
subdirectories. These  are  named  ide0,  ide1  and  so  on.  Each  of  these
directories contains the files shown in table 1-5.
 

Table 1-5: IDE controller info in  /proc/ide/ide?
..............................................................................
 File    Content                                 
 channel IDE channel (0 or 1)                    
 config  Configuration (only for PCI/IDE bridge) 
 mate    Mate name                               
 model   Type/Chipset of IDE controller          
..............................................................................
 
Each device  connected  to  a  controller  has  a separate subdirectory in the
controllers directory.  The  files  listed in table 1-6 are contained in these
directories.
 

Table 1-6: IDE device information
..............................................................................
 File             Content                                    
 cache            The cache                                  
 capacity         Capacity of the medium (in 512Byte blocks) 
 driver           driver and version                         
 geometry         physical and logical geometry              
 identify         device identify block                      
 media            media type                                 
 model            device identifier                          
 settings         device setup                               
 smart_thresholds IDE disk management thresholds             
 smart_values     IDE disk management values                 
..............................................................................
 
The most  interesting  file is settings. This file contains a nice overview of
the drive parameters:
 
  # cat /proc/ide/ide0/hda/settings 
  name                    value           min             max             mode 
  ----                    -----           ---             ---             ---- 
  bios_cyl                526             0               65535           rw 
  bios_head               255             0               255             rw 
  bios_sect               63              0               63              rw 
  breada_readahead        4               0               127             rw 
  bswap                   0               0               1               r 
  file_readahead          72              0               2097151         rw 
  io_32bit                0               0               3               rw 
  keepsettings            0               0               1               rw 
  max_kb_per_request      122             1               127             rw 
  multcount               0               0               8               rw 
  nice1                   1               0               1               rw 
  nowerr                  0               0               1               rw 
  pio_mode                write-only      0               255             w 
  slow                    0               0               1               rw 
  unmaskirq               0               0               1               rw 
  using_dma               0               0               1               rw 
 

1.4 Networking info in /proc/net
--------------------------------
 
The subdirectory  /proc/net  follows  the  usual  pattern. Table 1-6 shows the
additional values  you  get  for  IP  version 6 if you configure the kernel to
support this. Table 1-7 lists the files and their meaning.
 

Table 1-6: IPv6 info in /proc/net 
..............................................................................
 File       Content                                               
 udp6       UDP sockets (IPv6)                                    
 tcp6       TCP sockets (IPv6)                                    
 raw6       Raw device statistics (IPv6)                          
 igmp6      IP multicast addresses, which this host joined (IPv6) 
 if_inet6   List of IPv6 interface addresses                      
 ipv6_route Kernel routing table for IPv6                         
 rt6_stats  Global IPv6 routing tables statistics                 
 sockstat6  Socket statistics (IPv6)                              
 snmp6      Snmp data (IPv6)                                      
..............................................................................
 

Table 1-7: Network info in /proc/net 
..............................................................................
 File          Content                                                         
 arp           Kernel  ARP table                                               
 dev           network devices with statistics                                 
 dev_mcast     the Layer2 multicast groups a device is listening too
               (interface index, label, number of references, number of bound
               addresses). 
 dev_stat      network device status                                           
 ip_fwchains   Firewall chain linkage                                          
 ip_fwnames    Firewall chain names                                            
 ip_masq       Directory containing the masquerading tables                    
 ip_masquerade Major masquerading table                                        
 netstat       Network statistics                                              
 raw           raw device statistics                                           
 route         Kernel routing table                                            
 rpc           Directory containing rpc info                                   
 rt_cache      Routing cache                                                   
 snmp          SNMP data                                                       
 sockstat      Socket statistics                                               
 tcp           TCP  sockets                                                    
 tr_rif        Token ring RIF routing table                                    
 udp           UDP sockets                                                     
 unix          UNIX domain sockets                                             
 wireless      Wireless interface data (Wavelan etc)                           
 igmp          IP multicast addresses, which this host joined                  
 psched        Global packet scheduler parameters.                             
 netlink       List of PF_NETLINK sockets                                      
 ip_mr_vifs    List of multicast virtual interfaces                            
 ip_mr_cache   List of multicast routing cache                                 
..............................................................................
 
You can  use  this  information  to see which network devices are available in
your system and how much traffic was routed over those devices:
 
  > cat /proc/net/dev 
  Inter-|Receive                                                   |[... 
   face |bytes    packets errs drop fifo frame compressed multicast|[... 
      lo:  908188   5596     0    0    0     0          0         0 [...         
    ppp0:15475140  20721   410    0    0   410          0         0 [...  
    eth0:  614530   7085     0    0    0     0          0         1 [... 
   
  ...] Transmit 
  ...] bytes    packets errs drop fifo colls carrier compressed 
  ...]  908188     5596    0    0    0     0       0          0 
  ...] 1375103    17405    0    0    0     0       0          0 
  ...] 1703981     5535    0    0    0     3       0          0 
 
In addition, each Channel Bond interface has it's own directory.  For
example, the bond0 device will have a directory called /proc/net/bond0/.
It will contain information that is specific to that bond, such as the
current slaves of the bond, the link status of the slaves, and how
many times the slaves link has failed.
 
1.5 SCSI info
-------------
 
If you  have  a  SCSI  host adapter in your system, you'll find a subdirectory
named after  the driver for this adapter in /proc/scsi. You'll also see a list
of all recognized SCSI devices in /proc/scsi:
 
  >cat /proc/scsi/scsi 
  Attached devices: 
  Host: scsi0 Channel: 00 Id: 00 Lun: 00 
    Vendor: IBM      Model: DGHS09U          Rev: 03E0 
    Type:   Direct-Access                    ANSI SCSI revision: 03 
  Host: scsi0 Channel: 00 Id: 06 Lun: 00 
    Vendor: PIONEER  Model: CD-ROM DR-U06S   Rev: 1.04 
    Type:   CD-ROM                           ANSI SCSI revision: 02 
 

The directory  named  after  the driver has one file for each adapter found in
the system.  These  files  contain information about the controller, including
the used  IRQ  and  the  IO  address range. The amount of information shown is
dependent on  the adapter you use. The example shows the output for an Adaptec
AHA-2940 SCSI adapter:
 
  > cat /proc/scsi/aic7xxx/0 
   
  Adaptec AIC7xxx driver version: 5.1.19/3.2.4 
  Compile Options: 
    TCQ Enabled By Default : Disabled 
    AIC7XXX_PROC_STATS     : Disabled 
    AIC7XXX_RESET_DELAY    : 5 
  Adapter Configuration: 
             SCSI Adapter: Adaptec AHA-294X Ultra SCSI host adapter 
                             Ultra Wide Controller 
      PCI MMAPed I/O Base: 0xeb001000 
   Adapter SEEPROM Config: SEEPROM found and used. 
        Adaptec SCSI BIOS: Enabled 
                      IRQ: 10 
                     SCBs: Active 0, Max Active 2, 
                           Allocated 15, HW 16, Page 255 
               Interrupts: 160328 
        BIOS Control Word: 0x18b6 
     Adapter Control Word: 0x005b 
     Extended Translation: Enabled 
  Disconnect Enable Flags: 0xffff 
       Ultra Enable Flags: 0x0001 
   Tag Queue Enable Flags: 0x0000 
  Ordered Queue Tag Flags: 0x0000 
  Default Tag Queue Depth: 8 
      Tagged Queue By Device array for aic7xxx host instance 0: 
        {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255} 
      Actual queue depth per device for aic7xxx host instance 0: 
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1} 
  Statistics: 
  (scsi0:0:0:0) 
    Device using Wide/Sync transfers at 40.0 MByte/sec, offset 8 
    Transinfo settings: current(12/8/1/0), goal(12/8/1/0), user(12/15/1/0) 
    Total transfers 160151 (74577 reads and 85574 writes) 
  (scsi0:0:6:0) 
    Device using Narrow/Sync transfers at 5.0 MByte/sec, offset 15 
    Transinfo settings: current(50/15/0/0), goal(50/15/0/0), user(50/15/0/0) 
    Total transfers 0 (0 reads and 0 writes) 
 

1.6 Parallel port info in /proc/parport
---------------------------------------
 
The directory  /proc/parport  contains information about the parallel ports of
your system.  It  has  one  subdirectory  for  each port, named after the port
number (0,1,2,...).
 
These directories contain the four files shown in Table 1-8.
 

Table 1-8: Files in /proc/parport 
..............................................................................
 File      Content                                                             
 autoprobe Any IEEE-1284 device ID information that has been acquired.         
 devices   list of the device drivers using that port. A + will appear by the
           name of the device currently using the port (it might not appear
           against any). 
 hardware  Parallel port's base address, IRQ line and DMA channel.             
 irq       IRQ that parport is using for that port. This is in a separate
           file to allow you to alter it by writing a new value in (IRQ
           number or none). 
..............................................................................
 
1.7 TTY info in /proc/tty
-------------------------
 
Information about  the  available  and actually used tty's can be found in the
directory /proc/tty.You'll  find  entries  for drivers and line disciplines in
this directory, as shown in Table 1-9.
 

Table 1-9: Files in /proc/tty 
..............................................................................
 File          Content                                        
 drivers       list of drivers and their usage                
 ldiscs        registered line disciplines                    
 driver/serial usage statistic and status of single tty lines 
..............................................................................
 
To see  which  tty's  are  currently in use, you can simply look into the file
/proc/tty/drivers:
 
  > cat /proc/tty/drivers 
  pty_slave            /dev/pts      136   0-255 pty:slave 
  pty_master           /dev/ptm      128   0-255 pty:master 
  pty_slave            /dev/ttyp       3   0-255 pty:slave 
  pty_master           /dev/pty        2   0-255 pty:master 
  serial               /dev/cua        5   64-67 serial:callout 
  serial               /dev/ttyS       4   64-67 serial 
  /dev/tty0            /dev/tty0       4       0 system:vtmaster 
  /dev/ptmx            /dev/ptmx       5       2 system 
  /dev/console         /dev/console    5       1 system:console 
  /dev/tty             /dev/tty        5       0 system:/dev/tty 
  unknown              /dev/tty        4    1-63 console 
 

1.8 Miscellaneous kernel statistics in /proc/stat
-------------------------------------------------
 
Various pieces   of  information about  kernel activity  are  available in the
/proc/stat file.  All  of  the numbers reported  in  this file are  aggregates
since the system first booted.  For a quick look, simply cat the file:
 
  > cat /proc/stat
  cpu  2255 34 2290 22625563 6290 127 456 0
  cpu0 1132 34 1441 11311718 3675 127 438 0
  cpu1 1123 0 849 11313845 2614 0 18 0
  intr 114930548 113199788 3 0 5 263 0 4 [... lots more numbers ...]
  ctxt 1990473
  btime 1062191376
  processes 2915
  procs_running 1
  procs_blocked 0
 
The very first  "cpu" line aggregates the  numbers in all  of the other "cpuN"
lines.  These numbers identify the amount of time the CPU has spent performing
different kinds of work.  Time units are in USER_HZ (typically hundredths of a
second).  The meanings of the columns are as follows, from left to right:
 
- user: normal processes executing in user mode
- nice: niced processes executing in user mode
- system: processes executing in kernel mode
- idle: twiddling thumbs
- iowait: waiting for I/O to complete
- irq: servicing interrupts
- softirq: servicing softirqs
- steal: involuntary wait
 
The "intr" line gives counts of interrupts  serviced since boot time, for each
of the  possible system interrupts.   The first  column  is the  total of  all
interrupts serviced; each  subsequent column is the  total for that particular
interrupt.
 
The "ctxt" line gives the total number of context switches across all CPUs.
 
The "btime" line gives  the time at which the  system booted, in seconds since
the Unix epoch.
 
The "processes" line gives the number  of processes and threads created, which
includes (but  is not limited  to) those  created by  calls to the  fork() and
clone() system calls.
 
The  "procs_running" line gives the  number of processes  currently running on
CPUs.
 
The   "procs_blocked" line gives  the  number of  processes currently blocked,
waiting for I/O to complete.
 

------------------------------------------------------------------------------
Summary
------------------------------------------------------------------------------
The /proc file system serves information about the running system. It not only
allows access to process data but also allows you to request the kernel status
by reading files in the hierarchy.
 
The directory  structure  of /proc reflects the types of information and makes
it easy, if not obvious, where to look for specific data.
------------------------------------------------------------------------------
 
------------------------------------------------------------------------------
CHAPTER 2: MODIFYING SYSTEM PARAMETERS
------------------------------------------------------------------------------
 
------------------------------------------------------------------------------
In This Chapter
------------------------------------------------------------------------------
* Modifying kernel parameters by writing into files found in /proc/sys
* Exploring the files which modify certain parameters
* Review of the /proc/sys file tree
------------------------------------------------------------------------------
 

A very  interesting part of /proc is the directory /proc/sys. This is not only
a source  of  information,  it also allows you to change parameters within the
kernel. Be  very  careful  when attempting this. You can optimize your system,
but you  can  also  cause  it  to  crash.  Never  alter kernel parameters on a
production system.  Set  up  a  development machine and test to make sure that
everything works  the  way  you want it to. You may have no alternative but to
reboot the machine once an error has been made.
 
To change  a  value,  simply  echo  the new value into the file. An example is
given below  in the section on the file system data. You need to be root to do
this. You  can  create  your  own  boot script to perform this every time your
system boots.
 
The files  in /proc/sys can be used to fine tune and monitor miscellaneous and
general things  in  the operation of the Linux kernel. Since some of the files
can inadvertently  disrupt  your  system,  it  is  advisable  to  read  both
documentation and  source  before actually making adjustments. In any case, be
very careful  when  writing  to  any  of these files. The entries in /proc may
change slightly between the 2.1.* and the 2.2 kernel, so if there is any doubt
review the kernel documentation in the directory /usr/src/linux/Documentation.
This chapter  is  heavily  based  on the documentation included in the pre 2.2
kernels, and became part of it in version 2.2.1 of the Linux kernel.
 
2.1 /proc/sys/fs - File system data
-----------------------------------
 
This subdirectory  contains  specific  file system, file handle, inode, dentry
and quota information.
 
Currently, these files are in /proc/sys/fs:
 
dentry-state
------------
 
Status of  the  directory  cache.  Since  directory  entries  are  dynamically
allocated and  deallocated,  this  file indicates the current status. It holds
six values, in which the last two are not used and are always zero. The others
are listed in table 2-1.
 

Table 2-1: Status files of the directory cache 
..............................................................................
 File       Content                                                            
 nr_dentry  Almost always zero                                                 
 nr_unused  Number of unused cache entries                                     
 age_limit  
            in seconds after the entry may be reclaimed, when memory is short 
 want_pages internally                                                         
..............................................................................
 
dquot-nr and dquot-max
----------------------
 
The file dquot-max shows the maximum number of cached disk quota entries.
 
The file  dquot-nr  shows  the  number of allocated disk quota entries and the
number of free disk quota entries.
 
If the number of available cached disk quotas is very low and you have a large
number of simultaneous system users, you might want to raise the limit.
 
file-nr and file-max
--------------------
 
The kernel  allocates file handles dynamically, but doesn't free them again at
this time.
 
The value  in  file-max  denotes  the  maximum number of file handles that the
Linux kernel will allocate. When you get a lot of error messages about running
out of  file handles, you might want to raise this limit. The default value is
10% of  RAM in kilobytes.  To  change it, just  write the new number  into the
file:
 
  # cat /proc/sys/fs/file-max 
  4096 
  # echo 8192 > /proc/sys/fs/file-max 
  # cat /proc/sys/fs/file-max 
  8192 
 

This method  of  revision  is  useful  for  all customizable parameters of the
kernel - simply echo the new value to the corresponding file.
 
Historically, the three values in file-nr denoted the number of allocated file
handles,  the number of  allocated but  unused file  handles, and  the maximum
number of file handles. Linux 2.6 always  reports 0 as the number of free file
handles -- this  is not an error,  it just means that the  number of allocated
file handles exactly matches the number of used file handles.
 
Attempts to  allocate more  file descriptors than  file-max are  reported with
printk, look for "VFS: file-max limit <number> reached".
 
inode-state and inode-nr
------------------------
 
The file inode-nr contains the first two items from inode-state, so we'll skip
to that file...
 
inode-state contains  two  actual numbers and five dummy values. The numbers
are nr_inodes and nr_free_inodes (in order of appearance).
 
nr_inodes
~~~~~~~~~
 
Denotes the  number  of  inodes the system has allocated. This number will
grow and shrink dynamically.
 
nr_free_inodes
--------------
 
Represents the  number of free inodes. Ie. The number of inuse inodes is
(nr_inodes - nr_free_inodes).
 
aio-nr and aio-max-nr
---------------------
 
aio-nr is the running total of the number of events specified on the
io_setup system call for all currently active aio contexts.  If aio-nr
reaches aio-max-nr then io_setup will fail with EAGAIN.  Note that
raising aio-max-nr does not result in the pre-allocation or re-sizing
of any kernel data structures.
 
2.2 /proc/sys/fs/binfmt_misc - Miscellaneous binary formats
-----------------------------------------------------------
 
Besides these  files, there is the subdirectory /proc/sys/fs/binfmt_misc. This
handles the kernel support for miscellaneous binary formats.
 
Binfmt_misc provides  the ability to register additional binary formats to the
Kernel without  compiling  an additional module/kernel. Therefore, binfmt_misc
needs to  know magic numbers at the beginning or the filename extension of the
binary.
 
It works by maintaining a linked list of structs that contain a description of
a binary  format,  including  a  magic  with size (or the filename extension),
offset and  mask,  and  the  interpreter name. On request it invokes the given
interpreter with  the  original  program  as  argument,  as  binfmt_java  and
binfmt_em86 and  binfmt_mz  do.  Since binfmt_misc does not define any default
binary-formats, you have to register an additional binary-format.
 
There are two general files in binfmt_misc and one file per registered format.
The two general files are register and status.
 
Registering a new binary format
-------------------------------
 
To register a new binary format you have to issue the command
 
  echo :name:type:offset:magic:mask:interpreter: > /proc/sys/fs/binfmt_misc/register 
 
 
 
with appropriate  name (the name for the /proc-dir entry), offset (defaults to
0, if  omitted),  magic, mask (which can be omitted, defaults to all 0xff) and
last but  not  least,  the  interpreter that is to be invoked (for example and
testing /bin/echo).  Type  can be M for usual magic matching or E for filename
extension matching (give extension in place of magic).
 
Check or reset the status of the binary format handler
------------------------------------------------------
 
If you  do a cat on the file /proc/sys/fs/binfmt_misc/status, you will get the
current status (enabled/disabled) of binfmt_misc. Change the status by echoing
0 (disables)  or  1  (enables)  or  -1  (caution:  this  clears all previously
registered binary  formats)  to status. For example echo 0 > status to disable
binfmt_misc (temporarily).
 
Status of a single handler
--------------------------
 
Each registered  handler has an entry in /proc/sys/fs/binfmt_misc. These files
perform the  same function as status, but their scope is limited to the actual
binary format.  By  cating this file, you also receive all related information
about the interpreter/magic of the binfmt.
 
Example usage of binfmt_misc (emulate binfmt_java)
--------------------------------------------------
 
  cd /proc/sys/fs/binfmt_misc  
  echo ':Java:M::\xca\xfe\xba\xbe::/usr/local/java/bin/javawrapper:' > register  
  echo ':HTML:E::html::/usr/local/java/bin/appletviewer:' > register  
  echo ':Applet:M::<!--applet::/usr/local/java/bin/appletviewer:' > register 
  echo ':DEXE:M::\x0eDEX::/usr/bin/dosexec:' > register 
 

These four  lines  add  support  for  Java  executables and Java applets (like
binfmt_java, additionally  recognizing the .html extension with no need to put
<!--applet> to  every  applet  file).  You  have  to  install  the JDK and the
shell-script /usr/local/java/bin/javawrapper  too.  It  works  around  the
brokenness of  the Java filename handling. To add a Java binary, just create a
link to the class-file somewhere in the path.
 
2.3 /proc/sys/kernel - general kernel parameters
------------------------------------------------
 
This directory  reflects  general  kernel  behaviors. As I've said before, the
contents depend  on  your  configuration.  Here you'll find the most important
files, along with descriptions of what they mean and how to use them.
 
acct
----
 
The file contains three values; highwater, lowwater, and frequency.
 
It exists  only  when  BSD-style  process  accounting is enabled. These values
control its behavior. If the free space on the file system where the log lives
goes below  lowwater  percentage,  accounting  suspends.  If  it  goes  above
highwater percentage,  accounting  resumes. Frequency determines how often you
check the amount of free space (value is in seconds). Default settings are: 4,
2, and  30.  That is, suspend accounting if there is less than 2 percent free;
resume it  if we have a value of 3 or more percent; consider information about
the amount of free space valid for 30 seconds
 
audit_argv_kb
-------------
 
The file contains a single value denoting the limit on the argv array size
for execve (in KiB). This limit is only applied when system call auditing for
execve is enabled, otherwise the value is ignored.
 
ctrl-alt-del
------------
 
When the value in this file is 0, ctrl-alt-del is trapped and sent to the init
program to  handle a graceful restart. However, when the value is greater that
zero, Linux's  reaction  to  this key combination will be an immediate reboot,
without syncing its dirty buffers.
 
[NOTE]
    When a  program  (like  dosemu)  has  the  keyboard  in  raw  mode,  the
    ctrl-alt-del is  intercepted  by  the  program  before it ever reaches the
    kernel tty  layer,  and  it is up to the program to decide what to do with
    it.
 
domainname and hostname
-----------------------
 
These files  can  be controlled to set the NIS domainname and hostname of your
box. For the classic darkstar.frop.org a simple:
 
  # echo "darkstar" > /proc/sys/kernel/hostname 
  # echo "frop.org" > /proc/sys/kernel/domainname 
 

would suffice to set your hostname and NIS domainname.
 
osrelease, ostype and version
-----------------------------
 
The names make it pretty obvious what these fields contain:
 
  > cat /proc/sys/kernel/osrelease 
  2.2.12 
   
  > cat /proc/sys/kernel/ostype 
  Linux 
   
  > cat /proc/sys/kernel/version 
  #4 Fri Oct 1 12:41:14 PDT 1999 
 

The files  osrelease and ostype should be clear enough. Version needs a little
more clarification.  The  #4 means that this is the 4th kernel built from this
source base and the date after it indicates the time the kernel was built. The
only way to tune these values is to rebuild the kernel.
 
panic
-----
 
The value  in  this  file  represents  the  number of seconds the kernel waits
before rebooting  on  a  panic.  When  you  use  the  software  watchdog,  the
recommended setting  is  60. If set to 0, the auto reboot after a kernel panic
is disabled, which is the default setting.
 
printk
------
 
The four values in printk denote
* console_loglevel,
* default_message_loglevel,
* minimum_console_loglevel and
* default_console_loglevel
respectively.
 
These values  influence  printk()  behavior  when  printing  or  logging error
messages, which  come  from  inside  the  kernel.  See  syslog(2)  for  more
information on the different log levels.
 
console_loglevel
----------------
 
Messages with a higher priority than this will be printed to the console.
 
default_message_level
---------------------
 
Messages without an explicit priority will be printed with this priority.
 
minimum_console_loglevel
------------------------
 
Minimum (highest) value to which the console_loglevel can be set.
 
default_console_loglevel
------------------------
 
Default value for console_loglevel.
 
sg-big-buff
-----------
 
This file  shows  the size of the generic SCSI (sg) buffer. At this point, you
can't tune  it  yet,  but  you  can  change  it  at  compile  time  by editing
include/scsi/sg.h and changing the value of SG_BIG_BUFF.
 
If you use a scanner with SANE (Scanner Access Now Easy) you might want to set
this to a higher value. Refer to the SANE documentation on this issue.
 
modprobe
--------
 
The location  where  the  modprobe  binary  is  located.  The kernel uses this
program to load modules on demand.
 
unknown_nmi_panic
-----------------
 
The value in this file affects behavior of handling NMI. When the value is
non-zero, unknown NMI is trapped and then panic occurs. At that time, kernel
debugging information is displayed on console.
 
NMI switch that most IA32 servers have fires unknown NMI up, for example.
If a system hangs up, try pressing the NMI switch.
 
nmi_watchdog
------------
 
Enables/Disables the NMI watchdog on x86 systems.  When the value is non-zero
the NMI watchdog is enabled and will continuously test all online cpus to
determine whether or not they are still functioning properly.
 
Because the NMI watchdog shares registers with oprofile, by disabling the NMI
watchdog, oprofile may have more registers to utilize.
 
maps_protect
------------
 
Enables/Disables the protection of the per-process proc entries "maps" and
"smaps".  When enabled, the contents of these files are visible only to
readers that are allowed to ptrace() the given process.
 

2.4 /proc/sys/vm - The virtual memory subsystem
-----------------------------------------------
 
The files  in  this directory can be used to tune the operation of the virtual
memory (VM)  subsystem  of  the  Linux  kernel.
 
vfs_cache_pressure
------------------
 
Controls the tendency of the kernel to reclaim the memory which is used for
caching of directory and inode objects.
 
At the default value of vfs_cache_pressure=100 the kernel will attempt to
reclaim dentries and inodes at a "fair" rate with respect to pagecache and
swapcache reclaim.  Decreasing vfs_cache_pressure causes the kernel to prefer
to retain dentry and inode caches.  Increasing vfs_cache_pressure beyond 100
causes the kernel to prefer to reclaim dentries and inodes.
 
dirty_background_ratio
----------------------
 
Contains, as a percentage of total system memory, the number of pages at which
the pdflush background writeback daemon will start writing out dirty data.
 
dirty_ratio
-----------------
 
Contains, as a percentage of total system memory, the number of pages at which
a process which is generating disk writes will itself start writing out dirty
data.
 
dirty_writeback_centisecs
-------------------------
 
The pdflush writeback daemons will periodically wake up and write `old' data
out to disk.  This tunable expresses the interval between those wakeups, in
100'ths of a second.
 
Setting this to zero disables periodic writeback altogether.
 
dirty_expire_centisecs
----------------------
 
This tunable is used to define when dirty data is old enough to be eligible
for writeout by the pdflush daemons.  It is expressed in 100'ths of a second. 
Data which has been dirty in-memory for longer than this interval will be
written out next time a pdflush daemon wakes up.
 
legacy_va_layout
----------------
 
If non-zero, this sysctl disables the new 32-bit mmap mmap layout - the kernel
will use the legacy (2.4) layout for all processes.
 
lower_zone_protection
---------------------
 
For some specialised workloads on highmem machines it is dangerous for
the kernel to allow process memory to be allocated from the "lowmem"
zone.  This is because that memory could then be pinned via the mlock()
system call, or by unavailability of swapspace.
 
And on large highmem machines this lack of reclaimable lowmem memory
can be fatal.
 
So the Linux page allocator has a mechanism which prevents allocations
which _could_ use highmem from using too much lowmem.  This means that
a certain amount of lowmem is defended from the possibility of being
captured into pinned user memory.
 
(The same argument applies to the old 16 megabyte ISA DMA region.  This
mechanism will also defend that region from allocations which could use
highmem or lowmem).
 
The `lower_zone_protection' tunable determines how aggressive the kernel is
in defending these lower zones.  The default value is zero - no
protection at all.
 
If you have a machine which uses highmem or ISA DMA and your
applications are using mlock(), or if you are running with no swap then
you probably should increase the lower_zone_protection setting.
 
The units of this tunable are fairly vague.  It is approximately equal
to "megabytes," so setting lower_zone_protection=100 will protect around 100
megabytes of the lowmem zone from user allocations.  It will also make
those 100 megabytes unavailable for use by applications and by
pagecache, so there is a cost.
 
The effects of this tunable may be observed by monitoring
/proc/meminfo:LowFree.  Write a single huge file and observe the point
at which LowFree ceases to fall.
 
A reasonable value for lower_zone_protection is 100.
 
page-cluster
------------
 
page-cluster controls the number of pages which are written to swap in
a single attempt.  The swap I/O size.
 
It is a logarithmic value - setting it to zero means "1 page", setting
it to 1 means "2 pages", setting it to 2 means "4 pages", etc.
 
The default value is three (eight pages at a time).  There may be some
small benefits in tuning this to a different value if your workload is
swap-intensive.
 
overcommit_memory
-----------------
 
Controls overcommit of system memory, possibly allowing processes
to allocate (but not use) more memory than is actually available.
 

0 - Heuristic overcommit handling. Obvious overcommits of
  address space are refused. Used for a typical system. It
  ensures a seriously wild allocation fails while allowing
  overcommit to reduce swap usage.  root is allowed to
  allocate slightly more memory in this mode. This is the
  default.
 
1 - Always overcommit. Appropriate for some scientific
  applications.
 
2 - Don't overcommit. The total address space commit
  for the system is not permitted to exceed swap plus a
  configurable percentage (default is 50) of physical RAM.
  Depending on the percentage you use, in most situations
  this means a process will not be killed while attempting
  to use already-allocated memory but will receive errors
  on memory allocation as appropriate.
 
overcommit_ratio
----------------
 
Percentage of physical memory size to include in overcommit calculations
(see above.)
 
Memory allocation limit = swapspace + physmem * (overcommit_ratio / 100)
 
 swapspace = total size of all swap areas
 physmem = size of physical memory in system
 
nr_hugepages and hugetlb_shm_group
----------------------------------
 
nr_hugepages configures number of hugetlb page reserved for the system.
 
hugetlb_shm_group contains group id that is allowed to create SysV shared
memory segment using hugetlb page.
 
hugepages_treat_as_movable
--------------------------
 
This parameter is only useful when kernelcore= is specified at boot time to
create ZONE_MOVABLE for pages that may be reclaimed or migrated. Huge pages
are not movable so are not normally allocated from ZONE_MOVABLE. A non-zero
value written to hugepages_treat_as_movable allows huge pages to be allocated
from ZONE_MOVABLE.
 
Once enabled, the ZONE_MOVABLE is treated as an area of memory the huge
pages pool can easily grow or shrink within. Assuming that applications are
not running that mlock() a lot of memory, it is likely the huge pages pool
can grow to the size of ZONE_MOVABLE by repeatedly entering the desired value
into nr_hugepages and triggering page reclaim.
 
laptop_mode
-----------
 
laptop_mode is a knob that controls "laptop mode". All the things that are
controlled by this knob are discussed in Documentation/laptop-mode.txt.
 
block_dump
----------
 
block_dump enables block I/O debugging when set to a nonzero value. More
information on block I/O debugging is in Documentation/laptop-mode.txt.
 
swap_token_timeout
------------------
 
This file contains valid hold time of swap out protection token. The Linux
VM has token based thrashing control mechanism and uses the token to prevent
unnecessary page faults in thrashing situation. The unit of the value is
second. The value would be useful to tune thrashing behavior.
 
drop_caches
-----------
 
Writing to this will cause the kernel to drop clean caches, dentries and
inodes from memory, causing that memory to become free.
 
To free pagecache:
 echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
 echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
 echo 3 > /proc/sys/vm/drop_caches
 
As this is a non-destructive operation and dirty objects are not freeable, the
user should run `sync' first.
 

2.5 /proc/sys/dev - Device specific parameters
----------------------------------------------
 
Currently there is only support for CDROM drives, and for those, there is only
one read-only  file containing information about the CD-ROM drives attached to
the system:
 
  >cat /proc/sys/dev/cdrom/info 
  CD-ROM information, Id: cdrom.c 2.55 1999/04/25 
   
  drive name:             sr0     hdb 
  drive speed:            32      40 
  drive # of slots:       1       0 
  Can close tray:         1       1 
  Can open tray:          1       1 
  Can lock tray:          1       1 
  Can change speed:       1       1 
  Can select disk:        0       1 
  Can read multisession:  1       1 
  Can read MCN:           1       1 
  Reports media changed:  1       1 
  Can play audio:         1       1 
 

You see two drives, sr0 and hdb, along with a list of their features.
 
2.6 /proc/sys/sunrpc - Remote procedure calls
---------------------------------------------
 
This directory  contains four files, which enable or disable debugging for the
RPC functions NFS, NFS-daemon, RPC and NLM. The default values are 0. They can
be set to one to turn debugging on. (The default value is 0 for each)
 
2.7 /proc/sys/net - Networking stuff
------------------------------------
 
The interface  to  the  networking  parts  of  the  kernel  is  located  in
/proc/sys/net. Table  2-3  shows all possible subdirectories. You may see only
some of them, depending on your kernel's configuration.
 

Table 2-3: Subdirectories in /proc/sys/net 
..............................................................................
 Directory Content             Directory  Content            
 core      General parameter   appletalk  Appletalk protocol 
 unix      Unix domain sockets netrom     NET/ROM            
 802       E802 protocol       ax25       AX25               
 ethernet  Ethernet protocol   rose       X.25 PLP layer     
 ipv4      IP version 4        x25        X.25 protocol      
 ipx       IPX                 token-ring IBM token ring     
 bridge    Bridging            decnet     DEC net            
 ipv6      IP version 6                   
..............................................................................
 
We will  concentrate  on IP networking here. Since AX15, X.25, and DEC Net are
only minor players in the Linux world, we'll skip them in this chapter. You'll
find some  short  info on Appletalk and IPX further on in this chapter. Review
the online  documentation  and the kernel source to get a detailed view of the
parameters for  those  protocols.  In  this  section  we'll  discuss  the
subdirectories printed  in  bold letters in the table above. As default values
are suitable for most needs, there is no need to change these values.
 
/proc/sys/net/core - Network core options
-----------------------------------------
 
rmem_default
------------
 
The default setting of the socket receive buffer in bytes.
 
rmem_max
--------
 
The maximum receive socket buffer size in bytes.
 
wmem_default
------------
 
The default setting (in bytes) of the socket send buffer.
 
wmem_max
--------
 
The maximum send socket buffer size in bytes.
 
message_burst and message_cost
------------------------------
 
These parameters  are used to limit the warning messages written to the kernel
log from  the  networking  code.  They  enforce  a  rate  limit  to  make  a
denial-of-service attack  impossible. A higher message_cost factor, results in
fewer messages that will be written. Message_burst controls when messages will
be dropped.  The  default  settings  limit  warning messages to one every five
seconds.
 
warnings
--------
 
This controls console messages from the networking stack that can occur because
of problems on the network like duplicate address or bad checksums. Normally,
this should be enabled, but if the problem persists the messages can be
disabled.
 

netdev_max_backlog
------------------
 
Maximum number  of  packets,  queued  on  the  INPUT  side, when the interface
receives packets faster than kernel can process them.
 
optmem_max
----------
 
Maximum ancillary buffer size allowed per socket. Ancillary data is a sequence
of struct cmsghdr structures with appended data.
 
/proc/sys/net/unix - Parameters for Unix domain sockets
-------------------------------------------------------
 
There are  only  two  files  in this subdirectory. They control the delays for
deleting and destroying socket descriptors.
 
2.8 /proc/sys/net/ipv4 - IPV4 settings
--------------------------------------
 
IP version  4  is  still the most used protocol in Unix networking. It will be
replaced by  IP version 6 in the next couple of years, but for the moment it's
the de  facto  standard  for  the  internet  and  is  used  in most networking
environments around  the  world.  Because  of the importance of this protocol,
we'll have a deeper look into the subtree controlling the behavior of the IPv4
subsystem of the Linux kernel.
 
Let's start with the entries in /proc/sys/net/ipv4.
 
ICMP settings
-------------
 
icmp_echo_ignore_all and icmp_echo_ignore_broadcasts
----------------------------------------------------
 
Turn on (1) or off (0), if the kernel should ignore all ICMP ECHO requests, or
just those to broadcast and multicast addresses.
 
Please note that if you accept ICMP echo requests with a broadcast/multi\-cast
destination address  your  network  may  be  used as an exploder for denial of
service packet flooding attacks to other hosts.
 
icmp_destunreach_rate, icmp_echoreply_rate, icmp_paramprob_rate and icmp_timeexeed_rate
---------------------------------------------------------------------------------------
 
Sets limits  for  sending  ICMP  packets  to specific targets. A value of zero
disables all  limiting.  Any  positive  value sets the maximum package rate in
hundredth of a second (on Intel systems).
 
IP settings
-----------
 
ip_autoconfig
-------------
 
This file contains the number one if the host received its IP configuration by
RARP, BOOTP, DHCP or a similar mechanism. Otherwise it is zero.
 
ip_default_ttl
--------------
 
TTL (Time  To  Live) for IPv4 interfaces. This is simply the maximum number of
hops a packet may travel.
 
ip_dynaddr
----------
 
Enable dynamic  socket  address rewriting on interface address change. This is
useful for dialup interface with changing IP addresses.
 
ip_forward
----------
 
Enable or  disable forwarding of IP packages between interfaces. Changing this
value resets  all other parameters to their default values. They differ if the
kernel is configured as host or router.
 
ip_local_port_range
-------------------
 
Range of  ports  used  by  TCP  and UDP to choose the local port. Contains two
numbers, the  first  number  is the lowest port, the second number the highest
local port.  Default  is  1024-4999.  Should  be  changed  to  32768-61000 for
high-usage systems.
 
ip_no_pmtu_disc
---------------
 
Global switch  to  turn  path  MTU  discovery off. It can also be set on a per
socket basis by the applications or on a per route basis.
 
ip_masq_debug
-------------
 
Enable/disable debugging of IP masquerading.
 
IP fragmentation settings
-------------------------
 
ipfrag_high_trash and ipfrag_low_trash
--------------------------------------
 
Maximum memory  used to reassemble IP fragments. When ipfrag_high_thresh bytes
of memory  is  allocated  for  this  purpose,  the  fragment handler will toss
packets until ipfrag_low_thresh is reached.
 
ipfrag_time
-----------
 
Time in seconds to keep an IP fragment in memory.
 
TCP settings
------------
 
tcp_ecn
-------
 
This file controls the use of the ECN bit in the IPv4 headers. This is a new
feature about Explicit Congestion Notification, but some routers and firewalls
block traffic that has this bit set, so it could be necessary to echo 0 to
/proc/sys/net/ipv4/tcp_ecn if you want to talk to these sites. For more info
you could read RFC2481.
 
tcp_retrans_collapse
--------------------
 
Bug-to-bug compatibility with some broken printers. On retransmit, try to send
larger packets to work around bugs in certain TCP stacks. Can be turned off by
setting it to zero.
 
tcp_keepalive_probes
--------------------
 
Number of  keep  alive  probes  TCP  sends  out,  until  it  decides  that the
connection is broken.
 
tcp_keepalive_time
------------------
 
How often  TCP  sends out keep alive messages, when keep alive is enabled. The
default is 2 hours.
 
tcp_syn_retries
---------------
 
Number of  times  initial  SYNs  for  a  TCP  connection  attempt  will  be
retransmitted. Should  not  be  higher  than 255. This is only the timeout for
outgoing connections,  for  incoming  connections the number of retransmits is
defined by tcp_retries1.
 
tcp_sack
--------
 
Enable select acknowledgments after RFC2018.
 
tcp_timestamps
--------------
 
Enable timestamps as defined in RFC1323.
 
tcp_stdurg
----------
 
Enable the  strict  RFC793 interpretation of the TCP urgent pointer field. The
default is  to  use  the  BSD  compatible interpretation of the urgent pointer
pointing to the first byte after the urgent data. The RFC793 interpretation is
to have  it  point  to  the last byte of urgent data. Enabling this option may
lead to interoperability problems. Disabled by default.
 
tcp_syncookies
--------------
 
Only valid  when  the  kernel  was  compiled  with CONFIG_SYNCOOKIES. Send out
syncookies when  the  syn backlog queue of a socket overflows. This is to ward
off the common 'syn flood attack'. Disabled by default.
 
Note that  the  concept  of a socket backlog is abandoned. This means the peer
may not  receive  reliable  error  messages  from  an  over loaded server with
syncookies enabled.
 
tcp_window_scaling
------------------
 
Enable window scaling as defined in RFC1323.
 
tcp_fin_timeout
---------------
 
The length  of  time  in  seconds  it  takes to receive a final FIN before the
socket is  always  closed.  This  is  strictly  a  violation  of  the  TCP
specification, but required to prevent denial-of-service attacks.
 
tcp_max_ka_probes
-----------------
 
Indicates how  many  keep alive probes are sent per slow timer run. Should not
be set too high to prevent bursts.
 
tcp_max_syn_backlog
-------------------
 
Length of  the per socket backlog queue. Since Linux 2.2 the backlog specified
in listen(2)  only  specifies  the  length  of  the  backlog  queue of already
established sockets. When more connection requests arrive Linux starts to drop
packets. When  syncookies  are  enabled the packets are still answered and the
maximum queue is effectively ignored.
 
tcp_retries1
------------
 
Defines how  often  an  answer  to  a  TCP connection request is retransmitted
before giving up.
 
tcp_retries2
------------
 
Defines how often a TCP packet is retransmitted before giving up.
 
Interface specific settings
---------------------------
 
In the directory /proc/sys/net/ipv4/conf you'll find one subdirectory for each
interface the  system  knows about and one directory calls all. Changes in the
all subdirectory  affect  all  interfaces,  whereas  changes  in  the  other
subdirectories affect  only  one  interface.  All  directories  have  the same
entries:
 
accept_redirects
----------------
 
This switch  decides  if the kernel accepts ICMP redirect messages or not. The
default is 'yes' if the kernel is configured for a regular host and 'no' for a
router configuration.
 
accept_source_route
-------------------
 
Should source  routed  packages  be  accepted  or  declined.  The  default  is
dependent on  the  kernel  configuration.  It's 'yes' for routers and 'no' for
hosts.
 
bootp_relay
~~~~~~~~~~~
 
Accept packets  with source address 0.b.c.d with destinations not to this host
as local ones. It is supposed that a BOOTP relay daemon will catch and forward
such packets.
 
The default  is  0,  since this feature is not implemented yet (kernel version
2.2.12).
 
forwarding
----------
 
Enable or disable IP forwarding on this interface.
 
log_martians
------------
 
Log packets with source addresses with no known route to kernel log.
 
mc_forwarding
-------------
 
Do multicast routing. The kernel needs to be compiled with CONFIG_MROUTE and a
multicast routing daemon is required.
 
proxy_arp
---------
 
Does (1) or does not (0) perform proxy ARP.
 
rp_filter
---------
 
Integer value determines if a source validation should be made. 1 means yes, 0
means no.  Disabled by default, but local/broadcast address spoofing is always
on.
 
If you  set this to 1 on a router that is the only connection for a network to
the net,  it  will  prevent  spoofing  attacks  against your internal networks
(external addresses  can  still  be  spoofed), without the need for additional
firewall rules.
 
secure_redirects
----------------
 
Accept ICMP  redirect  messages  only  for gateways, listed in default gateway
list. Enabled by default.
 
shared_media
------------
 
If it  is  not  set  the kernel does not assume that different subnets on this
device can communicate directly. Default setting is 'yes'.
 
send_redirects
--------------
 
Determines whether to send ICMP redirects to other hosts.
 
Routing settings
----------------
 
The directory  /proc/sys/net/ipv4/route  contains  several  file  to  control
routing issues.
 
error_burst and error_cost
--------------------------
 
These  parameters  are used to limit how many ICMP destination unreachable to 
send  from  the  host  in question. ICMP destination unreachable messages are 
sent  when  we  cannot reach  the next hop while trying to transmit a packet. 
It  will also print some error messages to kernel logs if someone is ignoring 
our   ICMP  redirects.  The  higher  the  error_cost  factor  is,  the  fewer 
destination  unreachable  and error messages will be let through. Error_burst 
controls  when  destination  unreachable  messages and error messages will be
dropped. The default settings limit warning messages to five every second.
 
flush
-----
 
Writing to this file results in a flush of the routing cache.
 
gc_elasticity, gc_interval, gc_min_interval_ms, gc_timeout, gc_thresh
---------------------------------------------------------------------
 
Values to  control  the  frequency  and  behavior  of  the  garbage collection
algorithm for the routing cache. gc_min_interval is deprecated and replaced
by gc_min_interval_ms.
 

max_size
--------
 
Maximum size  of  the routing cache. Old entries will be purged once the cache
reached has this size.
 
max_delay, min_delay
--------------------
 
Delays for flushing the routing cache.
 
redirect_load, redirect_number
------------------------------
 
Factors which  determine  if  more ICPM redirects should be sent to a specific
host. No  redirects  will be sent once the load limit or the maximum number of
redirects has been reached.
 
redirect_silence
----------------
 
Timeout for redirects. After this period redirects will be sent again, even if
this has been stopped, because the load or number limit has been reached.
 
Network Neighbor handling
-------------------------
 
Settings about how to handle connections with direct neighbors (nodes attached
to the same link) can be found in the directory /proc/sys/net/ipv4/neigh.
 
As we  saw  it  in  the  conf directory, there is a default subdirectory which
holds the  default  values, and one directory for each interface. The contents
of the  directories  are identical, with the single exception that the default
settings contain additional options to set garbage collection parameters.
 
In the interface directories you'll find the following entries:
 
base_reachable_time, base_reachable_time_ms
-------------------------------------------
 
A base  value  used for computing the random reachable time value as specified
in RFC2461.
 
Expression of base_reachable_time, which is deprecated, is in seconds.
Expression of base_reachable_time_ms is in milliseconds.
 
retrans_time, retrans_time_ms
-----------------------------
 
The time between retransmitted Neighbor Solicitation messages.
Used for address resolution and to determine if a neighbor is
unreachable.
 
Expression of retrans_time, which is deprecated, is in 1/100 seconds (for
IPv4) or in jiffies (for IPv6).
Expression of retrans_time_ms is in milliseconds.
 
unres_qlen
----------
 
Maximum queue  length  for a pending arp request - the number of packets which
are accepted from other layers while the ARP address is still resolved.
 
anycast_delay
-------------
 
Maximum for  random  delay  of  answers  to  neighbor solicitation messages in
jiffies (1/100  sec). Not yet implemented (Linux does not have anycast support
yet).
 
ucast_solicit
-------------
 
Maximum number of retries for unicast solicitation.
 
mcast_solicit
-------------
 
Maximum number of retries for multicast solicitation.
 
delay_first_probe_time
----------------------
 
Delay for  the  first  time  probe  if  the  neighbor  is  reachable.  (see
gc_stale_time)
 
locktime
--------
 
An ARP/neighbor  entry  is only replaced with a new one if the old is at least
locktime old. This prevents ARP cache thrashing.
 
proxy_delay
-----------
 
Maximum time  (real  time is random [0..proxytime]) before answering to an ARP
request for  which  we have an proxy ARP entry. In some cases, this is used to
prevent network flooding.
 
proxy_qlen
----------
 
Maximum queue length of the delayed proxy arp timer. (see proxy_delay).
 
app_solicit
----------
 
Determines the  number of requests to send to the user level ARP daemon. Use 0
to turn off.
 
gc_stale_time
-------------
 
Determines how  often  to  check  for stale ARP entries. After an ARP entry is
stale it  will  be resolved again (which is useful when an IP address migrates
to another  machine).  When  ucast_solicit is greater than 0 it first tries to
send an  ARP  packet  directly  to  the  known  host  When  that  fails  and
mcast_solicit is greater than 0, an ARP request is broadcasted.
 
2.9 Appletalk
-------------
 
The /proc/sys/net/appletalk  directory  holds the Appletalk configuration data
when Appletalk is loaded. The configurable parameters are:
 
aarp-expiry-time
----------------
 
The amount  of  time  we keep an ARP entry before expiring it. Used to age out
old hosts.
 
aarp-resolve-time
-----------------
 
The amount of time we will spend trying to resolve an Appletalk address.
 
aarp-retransmit-limit
---------------------
 
The number of times we will retransmit a query before giving up.
 
aarp-tick-time
--------------
 
Controls the rate at which expires are checked.
 
The directory  /proc/net/appletalk  holds the list of active Appletalk sockets
on a machine.
 
The fields  indicate  the DDP type, the local address (in network:node format)
the remote  address,  the  size of the transmit pending queue, the size of the
received queue  (bytes waiting for applications to read) the state and the uid
owning the socket.
 
/proc/net/atalk_iface lists  all  the  interfaces  configured for appletalk.It
shows the  name  of the interface, its Appletalk address, the network range on
that address  (or  network number for phase 1 networks), and the status of the
interface.
 
/proc/net/atalk_route lists  each  known  network  route.  It lists the target
(network) that the route leads to, the router (may be directly connected), the
route flags, and the device the route is using.
 
2.10 IPX
--------
 
The IPX protocol has no tunable values in proc/sys/net.
 
The IPX  protocol  does,  however,  provide  proc/net/ipx. This lists each IPX
socket giving  the  local  and  remote  addresses  in  Novell  format (that is
network:node:port). In  accordance  with  the  strange  Novell  tradition,
everything but the port is in hex. Not_Connected is displayed for sockets that
are not  tied to a specific remote address. The Tx and Rx queue sizes indicate
the number  of  bytes  pending  for  transmission  and  reception.  The  state
indicates the  state  the  socket  is  in and the uid is the owning uid of the
socket.
 
The /proc/net/ipx_interface  file lists all IPX interfaces. For each interface
it gives  the network number, the node number, and indicates if the network is
the primary  network.  It  also  indicates  which  device  it  is bound to (or
Internal for  internal  networks)  and  the  Frame  Type if appropriate. Linux
supports 802.3,  802.2,  802.2  SNAP  and DIX (Blue Book) ethernet framing for
IPX.
 
The /proc/net/ipx_route  table  holds  a list of IPX routes. For each route it
gives the  destination  network, the router node (or Directly) and the network
address of the router (or Connected) for internal networks.
 
2.11 /proc/sys/fs/mqueue - POSIX message queues filesystem
----------------------------------------------------------
 
The "mqueue"  filesystem provides  the necessary kernel features to enable the
creation of a  user space  library that  implements  the  POSIX message queues
API (as noted by the  MSG tag in the  POSIX 1003.1-2001 version  of the System
Interfaces specification.)
 
The "mqueue" filesystem contains values for determining/setting  the amount of
resources used by the file system.
 
/proc/sys/fs/mqueue/queues_max is a read/write  file for  setting/getting  the
maximum number of message queues allowed on the system.
 
/proc/sys/fs/mqueue/msg_max  is  a  read/write file  for  setting/getting  the
maximum number of messages in a queue value.  In fact it is the limiting value
for another (user) limit which is set in mq_open invocation. This attribute of
a queue must be less or equal then msg_max.
 
/proc/sys/fs/mqueue/msgsize_max is  a read/write  file for setting/getting the
maximum  message size value (it is every  message queue's attribute set during
its creation).
 
2.12 /proc/<pid>/oom_adj - Adjust the oom-killer score
------------------------------------------------------
 
This file can be used to adjust the score used to select which processes
should be killed in an  out-of-memory  situation.  Giving it a high score will
increase the likelihood of this process being killed by the oom-killer.  Valid
values are in the range -16 to +15, plus the special value -17, which disables
oom-killing altogether for this process.
 
2.13 /proc/<pid>/oom_score - Display current oom-killer score
-------------------------------------------------------------
 
------------------------------------------------------------------------------
This file can be used to check the current score used by the oom-killer is for
any given <pid>. Use it together with /proc/<pid>/oom_adj to tune which
process should be killed in an out-of-memory situation.
 
------------------------------------------------------------------------------
Summary
------------------------------------------------------------------------------
Certain aspects  of  kernel  behavior  can be modified at runtime, without the
need to  recompile  the kernel, or even to reboot the system. The files in the
/proc/sys tree  can  not only be read, but also modified. You can use the echo
command to write value into these files, thereby changing the default settings
of the kernel.
------------------------------------------------------------------------------
 
2.14  /proc/<pid>/io - Display the IO accounting fields
-------------------------------------------------------
 
This file contains IO statistics for each running process
 
Example
-------
 
test:/tmp # dd if=/dev/zero of=/tmp/test.dat &
[1] 3828
 
test:/tmp # cat /proc/3828/io
rchar: 323934931
wchar: 323929600
syscr: 632687
syscw: 632675
read_bytes: 0
write_bytes: 323932160
cancelled_write_bytes: 0
 

Description
-----------
 
rchar
-----
 
I/O counter: chars read
The number of bytes which this task has caused to be read from storage. This
is simply the sum of bytes which this process passed to read() and pread().
It includes things like tty IO and it is unaffected by whether or not actual
physical disk IO was required (the read might have been satisfied from
pagecache)
 

wchar
-----
 
I/O counter: chars written
The number of bytes which this task has caused, or shall cause to be written
to disk. Similar caveats apply here as with rchar.
 

syscr
-----
 
I/O counter: read syscalls
Attempt to count the number of read I/O operations, i.e. syscalls like read()
and pread().
 

syscw
-----
 
I/O counter: write syscalls
Attempt to count the number of write I/O operations, i.e. syscalls like
write() and pwrite().
 

read_bytes
----------
 
I/O counter: bytes read
Attempt to count the number of bytes which this process really did cause to
be fetched from the storage layer. Done at the submit_bio() level, so it is
accurate for block-backed filesystems. <please add status regarding NFS and
CIFS at a later time>
 

write_bytes
-----------
 
I/O counter: bytes written
Attempt to count the number of bytes which this process caused to be sent to
the storage layer. This is done at page-dirtying time.
 

cancelled_write_bytes
---------------------
 
The big inaccuracy here is truncate. If a process writes 1MB to a file and
then deletes the file, it will in fact perform no writeout. But it will have
been accounted as having caused 1MB of write.
In other words: The number of bytes which this process caused to not happen,
by truncating pagecache. A task can cause "negative" IO too. If this task
truncates some dirty pagecache, some IO which another task has been accounted
for (in it's write_bytes) will not be happening. We _could_ just subtract that
from the truncating task's write_bytes, but there is information loss in doing
that.
 

Note
----
 
At its current implementation state, this is a bit racy on 32-bit machines: if
process A reads process B's /proc/pid/io while process B is updating one of
those 64-bit counters, process A could see an intermediate result.
 

More information about this can be found within the taskstats documentation in
Documentation/accounting.
 
2.15 /proc/<pid>/coredump_filter - Core dump filtering settings
---------------------------------------------------------------
When a process is dumped, all anonymous memory is written to a core file as
long as the size of the core file isn't limited. But sometimes we don't want
to dump some memory segments, for example, huge shared memory. Conversely,
sometimes we want to save file-backed memory segments into a core file, not
only the individual files.
 
/proc/<pid>/coredump_filter allows you to customize which memory segments
will be dumped when the <pid> process is dumped. coredump_filter is a bitmask
of memory types. If a bit of the bitmask is set, memory segments of the
corresponding memory type are dumped, otherwise they are not dumped.
 
The following 4 memory types are supported:
  - (bit 0) anonymous private memory
  - (bit 1) anonymous shared memory
  - (bit 2) file-backed private memory
  - (bit 3) file-backed shared memory
 
  Note that MMIO pages such as frame buffer are never dumped and vDSO pages
  are always dumped regardless of the bitmask status.
 
Default value of coredump_filter is 0x3; this means all anonymous memory
segments are dumped.
 
If you don't want to dump all shared memory segments attached to pid 1234,
write 1 to the process's proc file.
 
  $ echo 0x1 > /proc/1234/coredump_filter
 
When a new process is created, the process inherits the bitmask status from its
parent. It is useful to set up coredump_filter before the program runs.
For example:
 
  $ echo 0x7 > /proc/self/coredump_filter
  $ ./some_program
 
------------------------------------------------------------------------------ 

 
发表于： 2008-04-22 ，修改于： 2008-04-22 11:18，已浏览208次，有评论0条 推荐 投诉  
 
  
 
  

网友评论 
 
 

发表评论 
